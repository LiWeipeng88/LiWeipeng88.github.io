{"meta":{"title":"李伟朋@博客","subtitle":"Today's pay, tomorrow's harvest","description":"Today's pay, tomorrow's harvest","author":"liweipeng","url":"https://liweipeng88.github.io","root":"/"},"pages":[{"title":"about","date":"2020-06-09T09:21:22.000Z","updated":"2020-06-10T03:40:07.113Z","comments":true,"path":"about/index.html","permalink":"https://liweipeng88.github.io/about/index.html","excerpt":"","text":"个人介绍1. 基本信息 姓名 电话 毕业院校 学历 邮箱 工作经验 李伟朋 15769294114 西安电子科技大学 大专 liweipeng_it@163.com 3 年以上 2. 求职意向工作地点：西安 期望职位：Web 前端工程师 3. 自我评价技术方面 1.掌握 HTML、CSS、JavaScript、AJAX，jQuery 的 Web 基础开发。 2.熟练使用 Dreamweaver, Visual Studio Code,Sublime Text 等工具开发前端页面 3.熟练使用 Photoshop，sketch 等切图工具进行进行切图。 4.前端框架了解 Bootstrap、AngularJS、jQuery 以及 zepto.js。 5.了解 HTML5 和 CSS3 技术,可以实现基本动画效果。 6.版本管理工具使用过 Git（命令行操作以及 SourceTree 操作）,SVN。 7.熟练掌握 Web 前端开发的流程和模式。 8.有手机端开发开发经验。 业务方面 1.互联网营销或广告系统开发经验 2.汽车电商网络开发相关经验 3.基于 OpenStack 私有云管理平台开发经验 4. 项目经验项目名称： 博客园 1 项目简介：博客园创立于 2004 年 1 月，是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界。 我的职责：负责系统样式和交互效果实现，和后台一起前后端接口联调。 5.工作经历2015 年 05 月 2015 年 12 月 上海 B 公司 2013 年 07 月—2015 年 5 月 上海 A 公司 6.教育经历 学校名称 学习时间 学历 专业 西安电子科技大学 2020.9 至 2022.7 大专 软件技术"},{"title":"yourdiy","date":"2020-06-10T02:01:14.000Z","updated":"2020-06-10T02:01:14.459Z","comments":true,"path":"yourdiy/index-1.html","permalink":"https://liweipeng88.github.io/yourdiy/index-1.html","excerpt":"","text":""},{"title":"yourdiy","date":"2020-06-09T09:21:47.000Z","updated":"2020-06-09T09:21:47.346Z","comments":true,"path":"yourdiy/index.html","permalink":"https://liweipeng88.github.io/yourdiy/index.html","excerpt":"","text":""}],"posts":[{"title":"浅谈前端八大UI库","slug":"浅谈前端八大UI库","date":"2020-05-15T16:00:00.000Z","updated":"2020-06-11T01:50:35.356Z","comments":true,"path":"2020/05/16/浅谈前端八大UI库/","link":"","permalink":"https://liweipeng88.github.io/2020/05/16/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%85%AB%E5%A4%A7UI%E5%BA%93/","excerpt":"","text":"1. Element-UI element-UI是现在基于Vue的一个非常好用的桌面端UI组件库 支持@vue/cli项目的直接添加，支持按需导入、国际化、支持自定义主题③文档清晰，学习成本低 提供的组件足够使用，UI的风格符合目前大众的普遍审美 如果你想要做一个公司级别的产品，那么Element-Ul基本可以满足需求，但是难免样式、风格会同质化严重 2. Vuetify vuetify是国外团队进行开发的一个基于vue的组件库 支持@vue/cli项目的直接添加，支持按需导入、国际化、提供了定制功能(样式、颜色、主题等等) 文档相对清晰，但是和国人的思维不太一样，导致学习成本相对高一些 提供的组件足够使用，并且提供了v-开头的扩展指令,还有付费专题模块 UI的风格使用的是Google推出的Material Design的设计风格,在国内推广度相对低一些 使用vuetify在UI样式上，会有- -些额外的风险,但是可以避免同质化的问题，比较适合些个人或者需要彰显个性的项目 3. Ant Design Ant Design是阿里巴巴-蚂蚁金服体验技术部所设计的- -个UI库, - -般用于基于React的项目 支持在create-react-app (React 官方脚手架)项目的直接添加， 支持按需导入、国际化、提供了定制主题 文档清晰，学习成本低，提供的组件足够使用，并且提供了精品社区服务 UI的风格符合目前大众的普遍审美 如果你想要做一个公司级别的产品， 那么Ant Design基本可以满足需求，但是难免样式、风格会同质化严重 6. Vant-UI Vant-UI是有赞前端团队所设计的一-个UI库, -般用于基于Vue的移动端项目 支持@vue/cli项目的直接添加，支持按需导入、国际化、提供了定制功能，(样式、颜色、主题等等) 文档清晰，学习成本低，UI的风格以及交互操作可以达到现在的主流标准 提供的组件足够使用，性能不错，并且提供了基于商城业务的成套组件 适用于web app或者基于移动端的网页开发 7. Framework7 Framework7是独立开发者所设计的一一个全功能框架。可以用来构建IOS. Android和桌面应用程序。 本身是一个独立的框架，同时也可以配合vue和react来使用。整体比较重 文档汉化不是很好，具有一定的学习成本。 提供的功能组件、交互视图足够强大,并且也有很多新的概念,性能优秀 UI 的风格以及交互操作可以达到原生APP 95%的体验 适用于没有资深前端开发工程师的公司使用。 8. WEUI weui是微信官方团队开发的一套同微信原生视觉体验一 致的基础样式库。 因为只应对微信内部网页和微信小程序，所以所提供的功能相对简单。 文档稍微乱-些。提供的功能组件有限，主要还是应对场景的问题。 提供的功能组件有限，主要还是应对场景的问题。 适用微信内部网页和微信小程序。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"UI库","slug":"web前端/UI库","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/UI%E5%BA%93/"}],"tags":[{"name":"UI库","slug":"UI库","permalink":"https://liweipeng88.github.io/tags/UI%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"浅谈前端八大UI库","slug":"浅谈前端八大UI库 - 副本","date":"2020-05-15T16:00:00.000Z","updated":"2020-06-18T10:02:38.728Z","comments":true,"path":"2020/05/16/浅谈前端八大UI库 - 副本/","link":"","permalink":"https://liweipeng88.github.io/2020/05/16/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%85%AB%E5%A4%A7UI%E5%BA%93%20-%20%E5%89%AF%E6%9C%AC/","excerpt":"","text":"1. Element-UI element-UI是现在基于Vue的一个非常好用的桌面端UI组件库 支持@vue/cli项目的直接添加，支持按需导入、国际化、支持自定义主题③文档清晰，学习成本低 提供的组件足够使用，UI的风格符合目前大众的普遍审美 如果你想要做一个公司级别的产品，那么Element-Ul基本可以满足需求，但是难免样式、风格会同质化严重 2. Vuetify vuetify是国外团队进行开发的一个基于vue的组件库 支持@vue/cli项目的直接添加，支持按需导入、国际化、提供了定制功能(样式、颜色、主题等等) 文档相对清晰，但是和国人的思维不太一样，导致学习成本相对高一些 提供的组件足够使用，并且提供了v-开头的扩展指令,还有付费专题模块 UI的风格使用的是Google推出的Material Design的设计风格,在国内推广度相对低一些 使用vuetify在UI样式上，会有- -些额外的风险,但是可以避免同质化的问题，比较适合些个人或者需要彰显个性的项目 3. Ant Design Ant Design是阿里巴巴-蚂蚁金服体验技术部所设计的- -个UI库, - -般用于基于React的项目 支持在create-react-app (React 官方脚手架)项目的直接添加， 支持按需导入、国际化、提供了定制主题 文档清晰，学习成本低，提供的组件足够使用，并且提供了精品社区服务 UI的风格符合目前大众的普遍审美 如果你想要做一个公司级别的产品， 那么Ant Design基本可以满足需求，但是难免样式、风格会同质化严重 6. Vant-UI Vant-UI是有赞前端团队所设计的一-个UI库, -般用于基于Vue的移动端项目 支持@vue/cli项目的直接添加，支持按需导入、国际化、提供了定制功能，(样式、颜色、主题等等) 文档清晰，学习成本低，UI的风格以及交互操作可以达到现在的主流标准 提供的组件足够使用，性能不错，并且提供了基于商城业务的成套组件 适用于web app或者基于移动端的网页开发 7. Framework7 Framework7是独立开发者所设计的一一个全功能框架。可以用来构建IOS. Android和桌面应用程序。 本身是一个独立的框架，同时也可以配合vue和react来使用。整体比较重 文档汉化不是很好，具有一定的学习成本。 提供的功能组件、交互视图足够强大,并且也有很多新的概念,性能优秀 UI 的风格以及交互操作可以达到原生APP 95%的体验 适用于没有资深前端开发工程师的公司使用。 8. WEUI weui是微信官方团队开发的一套同微信原生视觉体验一 致的基础样式库。 因为只应对微信内部网页和微信小程序，所以所提供的功能相对简单。 文档稍微乱-些。提供的功能组件有限，主要还是应对场景的问题。 提供的功能组件有限，主要还是应对场景的问题。 适用微信内部网页和微信小程序。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"UI库","slug":"web前端/UI库","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/UI%E5%BA%93/"}],"tags":[{"name":"UI库","slug":"UI库","permalink":"https://liweipeng88.github.io/tags/UI%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"请求接口的简单封装","slug":"nui-app里面的请求接口简单的封装","date":"2020-03-02T16:00:00.000Z","updated":"2020-07-08T01:38:47.796Z","comments":true,"path":"2020/03/03/nui-app里面的请求接口简单的封装/","link":"","permalink":"https://liweipeng88.github.io/2020/03/03/nui-app%E9%87%8C%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"新建一个封装接口的文件12345678910111213141516171819202122232425const BASE_URL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8082&#39;export const myRequest &#x3D; (options) &#x3D;&gt; &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; nui.request(&#123; url:BASE_URL + options.url, method: options.method || &#39;GET&#39;, data: options.data || &#123;&#125;, success: res &#x3D;&gt;&#123; if(res.data.status !&#x3D;&#x3D; 0)&#123; return nui.showToast(&#123; title:&#39;获取数据失败&#39; &#125;) &#125; resolve(res) &#125;, fail:(err) &#x3D;&gt;&#123; nui.showToast(&#123; title:&#39;请求接口失败&#39; &#125;) reject(err) &#125; &#125;) &#125;)&#125; 挂在到Vue原型上12345678910111213import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App&#39;import &#123; myRequest &#125; from &#39;.&#x2F;util&#x2F;api.js&#39;Vue.prototype.$myRequest &#x3D; myRequestVue.config.productionTip &#x3D; falseApp.mpType &#x3D; &#39;app&#39;const app &#x3D; new Vue(&#123; ...App&#125;)app.$mount() 要请求接口的页面12345678methods:&#123; async getSwipersList()&#123; const res &#x3D; await this.$myRequest(&#123; url:&#39;&#x2F;api&#x2F;getBanner&#39; &#125;) console.log(res) &#125; &#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Vue学习","slug":"web前端/Vue学习","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"vue-cli3项目搭建配置以及性能优化","slug":"vue3.0项目搭建和配置","date":"2020-02-10T16:00:00.000Z","updated":"2020-07-08T01:41:07.500Z","comments":true,"path":"2020/02/11/vue3.0项目搭建和配置/","link":"","permalink":"https://liweipeng88.github.io/2020/02/11/vue3.0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"[vue-cli3项目搭建配置以及性能优化]项目初始化 注意：安装前请确保有安装node.js，并且node&gt;=8.9 全局安装vue 1npm install -g @vue&#x2F;cli 如果之前安装了vue旧版本，查看vue –version 创建项目 1vue create vue-cli3-init(项目名) 注：名称不能采用驼峰 vue-cli3也可以采用UI面板进行配置，相对比较方便，目前先写命令行创建，后续再加上面板创建。 选择配置，默认配置还是手动，这里我选择手动Manually，继续回车会让你选择你想要功能。 （不用用git窗口，选择不了选项，可以使用上下方向来切换选项） 此处有两个选择： default (babel, eslint) 默认套餐，提供 babel 和 eslint 支持。 Manually select features 自己去选择需要的功能，提供更多的特性选择。比如如果想要支持 TypeScript，就应该选择这一项。 回车后可进行选择，8个功能特性，可以多选： 使用方向键在特性选项之间切换，使用空格键选中当前特性，使用 a 键切换选择所有，使用 i 键翻转选项。我的选择如下，请根据自己需要进行选择。 对于每一项的功能，此处做个简单描述： TypeScript 支持使用 TypeScript 书写源码。 Progressive Web App (PWA) Support PWA 支持。 Router 支持 vue-router 。 Vuex 支持 vuex 。 CSS Pre-processors 支持 CSS 预处理器。 Linter / Formatter 支持代码风格检查和格式化。 Unit Testing 支持单元测试。 E2E Testing 支持 E2E 测试。 是否选择history模式，根据自己需要选择。 是否选择预语言，根据自己需要选择。 是否ESlint输出，根据自己需要选择。 是否保存时或者提交时是进行ESlint校验，根据自己需要选择。 选择把配置文件放在外面，选择 In dedicated config files 要不要把当前的这一系列选项配置保存起来，方便下一次创建项目时复用。 项目初始化完成，进入项目: 123cd vue-cli3-init依赖安装完成之后启动项目：npm run serve 修改目录结构 用编辑器打开后可以看到目录结构。相对于vue-cli2精简了很多，减少了对webpack的配置。 node_modules 文件夹 项目依赖(对webpack进行了封装) public 文件夹 1.favicon.ico 是 网站图标 2.index.html 页面入口文件 src 文件夹 main.js 入口js assets 存放静态文件 components 存放公用组件 App.vue 入口vue文件 .eslintrc.js 配置 .gitignore 指定文件无需提交到git上 balel.config.js 使用一些预设 package.json 项目描述及依赖 package-lock.json 版本管理使用的文件 由于现在的目录结构不利于后期的开发，现在我们增加部分文件，待后续可以进行功能扩展。在src文件下：新建api文件夹，config文件夹,router文件夹，utils文件夹，views文件夹，store文件夹。并在其文件下建子目录，详细请参考目录截图： 多环境运行 由于我们的项目需要在不同环境下进行运行(开发，生产，测试等)，这避免我们需要多次的去切换请求的地址以及相关的配置，vue-cli2是可以直接在config文件中进行配置的，但是vue-cli3已经简化了，官方文档也有进行配置的说明，实现具体有以下2种方法，我比较偏向第二种。 第一种实现方法 1.在根目录新建2个文件，分别为.env.development，.env.production，.env.test。注意文件是只有后缀的。 .env.development 模式用于serve，开发环境，就是开始环境的时候会引用这个文件里面的配置 .env.production模式用于build，线上环境。 .env.test 测试环境 2.分别在文件内写上： 开发环境： 12&#x2F;&#x2F;.env.development VUE_APP_BASE_API &#x3D; &#39;需要请求API&#39; 线上环境： 12&#x2F;&#x2F;.env.productionVUE_APP_BASE_API &#x3D; &#39;需要请求API&#39; 测试环境： 12&#x2F;&#x2F;.env.testVUE_APP_BASE_API &#x3D; &#39;需要请求API&#39; 当需要用到该变量是可以用process.env.VUE_APP_BASE_API进行取值。 3.更改package.json文件 1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;test&quot;: &quot;vue-cli-service serve --mode test&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, 第二种实现方式 1.在config文件新建index.js文件，根据全局的环境变量来进行判断，并进行输出。代码如下： 12345678910111213141516171819&#x2F;&#x2F; 一些全局的config配置const modeUrlObj &#x3D; &#123; &#x2F;&#x2F; 生产环境 &#39;production&#39;: &#123; baseURL: &#39;http:&#x2F;&#x2F;xxx:9091&#x2F;pro&#x2F;&#39;, authBaseURL: &#39;&#39; &#125;, &#x2F;&#x2F; 开发环境 &#39;development&#39;: &#123; baseURL: &#39;http:&#x2F;&#x2F;xxxx:9091&#x2F;dev&#x2F;&#39;, authBaseURL: &#39;&#39; &#125;, &#x2F;&#x2F; 测试环境 &#39;test&#39;: &#123; baseURL: &#39;http:&#x2F;&#x2F;xxxx:9091&#x2F;test&#x2F;&#39;, authBaseURL: &#39;&#39; &#125;&#125;export default modeUrlObj[process.env.NODE_ENV] 2.更改package.json文件 1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;test&quot;: &quot;vue-cli-service serve --mode test&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, 3.引用的方法可以参照如下： 12import config from &#39;..&#x2F;config&#x2F;index&#39; &#x2F;&#x2F; 路径配置config.baseURL &#x2F;&#x2F; 对应环境api 4.运行命令行 1234npm run dev &#x2F;&#x2F; 开发环境npm run test &#x2F;&#x2F; 测试环境npm run build &#x2F;&#x2F; 正式环境打包npm run build:test &#x2F;&#x2F; 测试环境打包 axios封装 在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步axios文档。 安装依赖 1npm install axios --save; &#x2F;&#x2F; 安装axios 配置axios 在uitls文件下新增request.js文件，在这里我们对axios进行初始化后，暴露给需要引用的文件，方便开发。 12import axios from &#39;axios&#39;import config from &#39;..&#x2F;config&#x2F;index&#39; &#x2F;&#x2F; 路径配置 创建axios实例，并进行配置 12345&#x2F;&#x2F; 创建axios 实例const service &#x3D; axios.create(&#123; baseURL: config.baseURL, &#x2F;&#x2F; api的base_url timeout: 10000 &#x2F;&#x2F; 请求超时时间&#125;) 利用axios的请求拦截和响应拦截可以对登录和权限方面进行控制，具体需求可以自己进行配置。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import axios from &#39;axios&#39;import config from &#39;..&#x2F;config&#x2F;index&#39; &#x2F;&#x2F; 路径配置&#x2F;&#x2F; 创建axios 实例const service &#x3D; axios.create(&#123; baseURL: config.baseURL, &#x2F;&#x2F; api的base_url timeout: 10000 &#x2F;&#x2F; 请求超时时间&#125;)&#x2F;&#x2F; request 拦截器service.interceptors.request.use( config &#x3D;&gt; &#123; &#x2F;&#x2F; 这里可以自定义一些config 配置 return config &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 这里处理一些请求出错的情况 Promise.reject(error) &#125;)&#x2F;&#x2F; response 拦截器service.interceptors.response.use( response &#x3D;&gt; &#123; const res &#x3D; response.data &#x2F;&#x2F; 这里处理一些response 正常放回时的逻辑 return res &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 这里处理一些response 出错时的逻辑 return Promise.reject(error) &#125;)export default service api请求配置 在api文件下新建分类的api请求文件。根据具体需要分类。主要是方便团队开发，容易归类。可以参考下面配置。 12345678910111213141516171819import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123; &#x2F;&#x2F; 登录 login (data) &#123; return request(&#123; url: &#39;&#x2F;login&#39;, method: &#39;post&#39;, data &#125;) &#125;, &#x2F;&#x2F; 获取用户信息 getUserInfo () &#123; return request(&#123; url: &#39;&#x2F;userinfo&#39;, method: &#39;get&#39; &#125;) &#125;&#125; 业务中需要进行请求可以用import后，进行传参即可。 模块化vuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 如果对vuex还不大了解的可以自行阅读vuex官方文档。 安装vuex 1npm install vuex -S 新建目录 modules文件主要用法存放分类的文件，可以进行区分，getters文件是对state进行处理，index.js主要进行一些引入，初始化操作。 书写vuex配置 index.js文件 123456789101112131415import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import user from &#39;.&#x2F;modules&#x2F;user&#39; &#x2F;&#x2F; 引入各个模块的代码import getters from &#39;.&#x2F;getters&#39;Vue.use(Vuex)const store &#x3D; new Vuex.Store(&#123; modules: &#123; user &#125;, getters&#125;)export default store getter.js文件 getter中的配置可根据需求进行增加或者删除，下面是示例。 123456789const getters &#x3D; &#123; requestLoading: state &#x3D;&gt; state.app.requestLoading, size: state &#x3D;&gt; state.app.size, token: state &#x3D;&gt; state.user.token, avatar: state &#x3D;&gt; state.user.avatar, name: state &#x3D;&gt; state.user.name, roles: state &#x3D;&gt; state.user.roles&#125;export default getters moduels/user.js文件 该文件为与业务相关，可以跟据具体参见进行增加和删除命名。每个文件的基本配置和用法如下： 123456789101112131415161718192021222324252627282930313233import &#123; getToken, setToken &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;import api from &#39;@&#x2F;api&#x2F;user&#39;const user &#x3D; &#123; state: &#123; token: getToken(), &#125;, mutations: &#123; SET_TOKEN: (state, token) &#x3D;&gt; &#123; state.token &#x3D; token &#125;, &#125;, actions: &#123; &#x2F;&#x2F; 登录 Login (&#123; commit &#125;, userInfo) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; api.login(userInfo).then(res &#x3D;&gt; &#123; if (res.code &#x3D;&#x3D;&#x3D; 200) &#123; setToken(res.data) commit(&#39;SET_TOKEN&#39;, res.data) &#125; resolve() &#125;).catch(err &#x3D;&gt; &#123; reject(err) &#125;) &#125;) &#125; &#125;&#125;export default user 全局样式引用在项目开发过程中，我们经常需要全局样式引用，例如主题色等，如果每次去写的化会变得很麻烦。因为我们应该了sass预语言编译，所以可以大胆的应用其特性。例如变量，函数，混入等。但是我们需要在项目中进行全局的配置才能有效果。不用在每一个页面都进行引入样式，就能直接引用。 新建目录 在assets下新建如下文件，具体的代码自行进行配置 1234* common.scss 主要存放公共的样式* mixin.scss 存放混入样式* reset.scss 存放重置样式。* variable.scss 存放变量 全局引入 新建vue.config.js文件，并写上以下代码 12345678910111213141516module.exports &#x3D; &#123; css: &#123; loaderOptions: &#123; &#x2F;&#x2F; pass options to sass-loader sass: &#123; &#x2F;&#x2F; @&#x2F; is an alias to src&#x2F; &#x2F;&#x2F; so this assumes you have a file named &#96;src&#x2F;variables.scss&#96; data: &#96; @import &quot;@&#x2F;assets&#x2F;css&#x2F;variable.scss&quot;; @import &quot;@&#x2F;assets&#x2F;css&#x2F;common.scss&quot;; @import &quot;@&#x2F;assets&#x2F;css&#x2F;mixin.scss&quot;; &#96; &#125; &#125; &#125;,&#125; 在app.vue中引入reset.scss文件，完成后，样式即可进行全局调用了。 123&lt;style lang&#x3D;&quot;scss&quot;&gt; @import &quot;assets&#x2F;css&#x2F;reset&quot;;&lt;&#x2F;style&gt; 移动端适配配置在本项目中主要用rem来进行页面的适配操作的，因为rem就可以随根字体大小改变而改变，从而实现了自适应的功能。但是html的字体是固定的，所以需要监听页面大小的变化，我主要用了淘宝的amfe-flexible来进行监听改变的。将项目中css的px转成rem单位，免去计算烦恼,我们可以用scss来进行计算或者利用px2rem插件来进行自动转化。因为是开发移动端，需把mate换为``实现方法如下： 安装amfe-flexible 1npm i amfe-flexible --save px转rem 方法一： 在common.scss文件中，全局引入scss函数： 123456&#x2F;** 转化px为rem。$base-font-size &#x3D; 设计稿尺寸&#x2F;10*&#x2F;@function px2rem($px, $base-font-size: 37.5) &#123; @return ($px&#x2F;$base-font-size)*1rem&#125; 调用方式直接： width: px2rem(175); 方法二： 安装依赖 1npm i postcss-pxtorem --save-dev package.json内，在postcss内添加： 123456789&quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;: &#123;&#125;, &quot;postcss-pxtorem&quot;: &#123; &quot;rootValue&quot;: 75, &#x2F;&#x2F; 设计稿宽度的1&#x2F;10,（JSON文件中不加注释，此行注释及下行注释均删除） &quot;propList&quot;:[&quot;*&quot;] &#x2F;&#x2F; 需要做转化处理的属性，如&#96;hight&#96;、&#96;width&#96;、&#96;margin&#96;等，&#96;*&#96;表示全部 &#125; &#125; &#125;, 常用util该文件主要是对一些常用的js进行封装，例如时间格式化，LocalStorage操作等，相对比较常用的方法，这个文件可以进行保存，要用到时直接复制过来用即可。下面是我封装LocalStorage的文件，可参考以下，其他自行设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445import Cookies from &#39;js-cookie&#39;const TokenKey &#x3D; &#39;Authorization&#39;&#x2F;** 设置setLocalStorage* *&#x2F;export function setLocalStorage (key, value) &#123; window.localStorage.setItem(key, window.JSON.stringify(value))&#125;&#x2F;** 获取getLocalStorage* *&#x2F;export function getLocalStorage (key) &#123; return window.JSON.parse(window.localStorage.getItem(key) || &#39;[]&#39;)&#125;&#x2F;** 设置setSessionStorage* *&#x2F;export function setSessionStorage (key, value) &#123; window.sessionStorage.setItem(key, window.JSON.stringify(value))&#125;&#x2F;** 获取getSessionStorage* *&#x2F;export function getSessionStorage (key) &#123; return window.JSON.parse(window.sessionStorage.getItem(key) || &#39;[]&#39;)&#125;&#x2F;** 获取getToken* *&#x2F;export function getToken () &#123; return Cookies.get(TokenKey)&#125;&#x2F;** 设置setToken* *&#x2F;export function setToken (token) &#123; return Cookies.set(TokenKey, token)&#125;&#x2F;** 移除removeToken* *&#x2F;export function removeToken () &#123; return Cookies.remove(TokenKey)&#125; 引入第三方UI框架(elementUI) \\1. 打开控制台，执行vue add element命令，为项目安装element。 2.等待其安装完毕，在设置向导中配置引入方式和加载地区。 3.在自动安装完依赖后，可以看到相关的文件已经被创建/更新了。 4.如果需要按需引入，则去到src目录下自动新建的plugins目录，编辑element.js即可，默认会导入一个Button。这么做的好处是不用把引入的ele组件写在main.js文件下，使各模块更加分离。 配置vue.config.js文件基本配置 1.文件目录配置别名我们可以把src配置为@，如果需要就不用到根目录开始写了，直接用@/xxx/进行引用。根据自己需要进行配置，在vue.config.js文件中加入代码 12345678910111213&#x2F;&#x2F; 配置chainWebpack: (config)&#x3D;&gt;&#123;&#x2F;&#x2F; 配置别名config.resolve.alias .set(&#39;@&#39;, resolve(&#39;src&#39;)) .set(&#39;assets&#39;,resolve(&#39;src&#x2F;assets&#39;)) .set(&#39;components&#39;,resolve(&#39;src&#x2F;components&#39;)) .set(&#39;router&#39;,resolve(&#39;src&#x2F;router&#39;)) .set(&#39;utils&#39;,resolve(&#39;src&#x2F;utils&#39;)) .set(&#39;static&#39;,resolve(&#39;src&#x2F;static&#39;)) .set(&#39;store&#39;,resolve(&#39;src&#x2F;store&#39;)) .set(&#39;views&#39;,resolve(&#39;src&#x2F;views&#39;)) &#125; 2.跨域配置在前端请求过程中，如果后台没有设置跨域请求的，可以在webpack进行配置。 12345678devServer: &#123;proxy: &#123; &#39;&#x2F;api&#39;: &#123; target: &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#39;, changeOrigin: true &#125; &#125;&#125; 3.其他配置 具体可以参照官网的配置说明，在项目中我用到了 123assetsDir: &#39;assets&#39;, &#x2F;&#x2F; 静态文件目录publicPath: &#39;.&#x2F;&#39;, &#x2F;&#x2F; 编译后的地址，可以根据环境进行设置lintOnSave: true, &#x2F;&#x2F; 是否开启编译时是否不符合eslint提示 以上的所有代码必须写在module.exports输出才能生效. 详细的配置可参考官网 vue-cli3 项目框架性能优化 (v1_mint_ui分支)通过以上的基本配置，项目已经符合我们工作需要了，但是在工作过程中会发现随着项目的集成度越来越高，业务越来越多。出现了加载慢和打包文件过大的问题。导致我们页面白屏时间过长，用户体验不友好。那么如果你感兴趣的话，可以进行以下的配置，可以大大大大大的减小体积和加载速度。在master分支是没有进行优化的，如果需要看优化代码可以到另外一个分支。所以在页面引入的代码都是当前页面需要的执行代码，可以往下面几个方法进行处理。 js,css代码的最小化压缩和分割 js,css代码公用代码提取, 按需引入(cdn加载) 图片文件的压缩 gzip的压缩 去除console.log 1.js,css代码的最小化压缩和分割 首先，我们先对js文件进行配置以达到压缩效果，先看一下没有配置代码情况，整个app.js 的文件是2.8M（因为是初始项目），但是如果页面一多，就不只这个数了。 我们会通过chainWebpak来处理. 在优化前, 看下相关文件的响应代码: 看下app.js文件的返回代码:代码如下： 在vue.config.js文件中加入,run以下后查看app.js情况，文件会变小（由于初始项目体积小，看不出多大区别）。 12345module.exports &#x3D; &#123; chainWebpack: config &#x3D;&gt; &#123; config.optimization.minimize(true); &#125;&#125; 分割代码,相应的文件中存入分割后的代码。 123456789module.exports &#x3D; &#123; chainWebpack: config &#x3D;&gt; &#123; config.optimization.minimize(true); config.optimization.splitChunks(&#123; chunks: &#39;all&#39; &#125;) &#125;&#125; 加入以上代码后，分成了2个文件，最大的只有2.7M了，这样可以分成多个进行加载，可以达到最快化，但是一定要平衡文件大小的和分割出来的文件数量的平衡, 数量多了, 请求也会变慢的, 影响性能.可以根据项目的进行设置，具体可参考官方文档的详细说明。 2.js,css代码公用代码提取, 按需引入(CDN加载) 把公用代码提取出来,然后采用使用免费的cdn资源进行加载。在项目中我们主要是引入引入不同的模块库才会导致文件较大，那么是否可以把这些文件进一步处理，答案是可以的，比如vue, vuex, vue-router, element-ui等公共资源库。利用webpack我们可以使用externals参数来配置: 在vue.config.js文件: 123456789101112131415161718module.exports &#x3D; &#123; chainWebpack: config &#x3D;&gt; &#123; &#x2F;&#x2F; 压缩代码 config.optimization.minimize(true); &#x2F;&#x2F; 分割代码 config.optimization.splitChunks(&#123; chunks: &#39;all&#39; &#125;) &#x2F;&#x2F; 用cdn方式引入 config.externals(&#123; &#39;vue&#39;: &#39;Vue&#39;, &#39;vuex&#39;: &#39;Vuex&#39;, &#39;vue-router&#39;: &#39;VueRouter&#39;, &#39;mint-ui&#39;: &#39;MINT&#39;, &#x2F;&#x2F; 需用MINT &#39;axios&#39;: &#39;axios&#39; &#125;) &#125;&#125; index.html加入CDN地址,注意引入的时候要写在body里面，否则会报错。 12345&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.6.10&#x2F;vue.runtime.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue-router&#x2F;3.0.2&#x2F;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vuex&#x2F;3.1.0&#x2F;vuex.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;axios&#x2F;0.18.0&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mint-ui&#x2F;2.2.13&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt; mint-ui样式通过CDN引入。然后商储mian.js文件的 import ‘mint-ui/lib/style.css’ （全局引入模式才有） 1&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mint-ui&#x2F;2.2.13&#x2F;style.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; 如果需要引入其他依赖的CDN可以通过BootCDN查找进行引入。 重新运行项目, 看看效果，已经大大的减小了很多，到了k级别了： 提取css代码： 因为js会动态的加载出css，所以js文件包会比较大，那么需要提取css代码到文件. 这里我们只需要将css配置一下: 12345module.exports &#x3D; &#123; css: &#123; extract: true &#125;&#125; 3.图片文件的压缩 图片文件大于在webpack设定的值时，我们可以对其进行压缩在进行引入，安利给大家一个压缩图片的网站https://tinypng.com/，它可以批量的压缩图片又不会失真，压缩比相对较大。可以对图片进行有效压缩。 4.gzip的压缩 如果后台有对前端的代码进行gzip压缩的话，那么就不需要进行压缩了，后台自己配置就可以。如果后台不具备这种情况那么我们可以利用compression-webpack-plugin插件可以帮助我们进行gzip压缩： 安装依赖： 1npm install --save-dev compression-webpack-plugin 然后引入相关代码: 1234567891011121314151617181920212223242526272829303132const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)const compress &#x3D; new CompressionWebpackPlugin( &#123; filename: info &#x3D;&gt; &#123; return &#96;$&#123;info.path&#125;.gz$&#123;info.query&#125;&#96; &#125;, algorithm: &#39;gzip&#39;, threshold: 10240, test: new RegExp( &#39;\\\\.(&#39; + [&#39;js&#39;].join(&#39;|&#39;) + &#39;)$&#39; ), minRatio: 0.8, deleteOriginalAssets: false &#125;)module.exports &#x3D; &#123;devServer: &#123; before(app, server) &#123; app.get(&#x2F;.*.(js)$&#x2F;, (req, res, next) &#x3D;&gt; &#123; req.url &#x3D; req.url + &#39;.gz&#39;; res.set(&#39;Content-Encoding&#39;, &#39;gzip&#39;); next(); &#125;) &#125; &#125; configureWebpack: &#123; plugins: [compress] &#125; 重新run一遍，出现了意向不到的结果了。又原来的2.8M转化为250+kb了，缩小了11倍以上。重大突破 6.去除console.log 正常情况下我们会在开发环境进行console调试，但是如果不删除，过多会出现内存泄漏的情况，那么我们可以在正式环境的时候就把它给干掉，实现方法如下： 方法一： 1234567891011121314151617181920212223242526const UglifyJsPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;);module.exports &#x3D; &#123; configureWebpack: config &#x3D;&gt; &#123; if (IS_PROD) &#123; const plugins &#x3D; []; plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, drop_debugger: false, pure_funcs: [&#39;console.log&#39;]&#x2F;&#x2F;移除console &#125; &#125;, sourceMap: false, parallel: true &#125;) ); config.plugins &#x3D; [ ...config.plugins, ...plugins ]; &#125; &#125;&#125; 方法二：使用babel-plugin-transform-remove-console插件 1npm i --save-dev babel-plugin-transform-remove-console 在babel.config.js中配置 123456789const plugins &#x3D; [];if([&#39;production&#39;, &#39;prod&#39;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports &#x3D; &#123; presets: [[&quot;@vue&#x2F;app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]], plugins: plugins&#125;;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Vue学习","slug":"web前端/Vue学习","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"nodejs常用包","slug":"nodejs常用包","date":"2019-12-11T16:00:00.000Z","updated":"2020-06-10T08:18:47.683Z","comments":true,"path":"2019/12/12/nodejs常用包/","link":"","permalink":"https://liweipeng88.github.io/2019/12/12/nodejs%E5%B8%B8%E7%94%A8%E5%8C%85/","excerpt":"","text":"vue-lazyload图片懒加载，功能很全 axios支持 promise 的 http 库 amfe-flexible移动端适配 vue-meta组件中动态修改 head 标签里面的内容 webpack-bundle-analyzer打包完成后显示体积相关信息，可以了解是否重复加载,哪些文件过大等 html-webpack-include-assets-plugin用于添加 js 或 css 文件路径 vue-awesome-swiper移动端轮播图插件 swiper.animate1.0.3.min.js动画过渡插件 vue-wechat-title微信动态设置标题 uuid生成 uid(唯一标识符) md5md5 加密 weixin-js-sdk微信的 jssdk 库(微信分享) nodemon用 nodemon 来代替 node 来启动应用 rimraf以包的形式包装 rm -rf 命令，用来删除文件和文件夹的，不管文件夹是否为空，都可删除 babel-polyfillIE9 不支持 Promise,需安装 babel-polyfill qs数据格式转换插件，配合 axios 使用 fastclick移动端项目，点击事件会有 300ms 延迟的问题 1234567891011// main.jsimport FastClick from 'fastclick' // 解决移动端300毫秒延迟if ('addEventListener' in document) &#123; document.addEventListener( 'DOMContentLoaded', function() &#123; FastClick.attach(document.body) &#125;, false )&#125; fs-extrafs-extra 是 fs 的一个扩展 vue-contextmenu右键弹出菜单插件 vue-touch装了 hammer.js 的方法 vuex-persistedstatevuex 数据持久化 es6-promiserequire(‘es6-promise’).polyfill() vconsole手机端调试 console script-loader在全局上下文执行了一次 file.js 文档 123456789101112module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.exec\\.js$/, use: ['script-loader'] &#125; ] &#125;&#125;import exec from 'script-loader!./script.js' animate.csscss 动画库 1234567// main.js import animate from 'animate.css' Vue.use(animate)&lt;transition enter-active-class=\"animated zoomInLeft\" leave-active-class=\"animated zoomOutRight\"&gt;&lt;/transition&gt; vue-pano全景图插件 better-scroll滚动插件 vue-amap高德地图 vue-ba百度统计 vue-kindedtior富文本编辑器","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"web前端/nodejs","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://liweipeng88.github.io/tags/nodejs/"}],"author":"Li Weipeng"},{"title":"开发测试环境的灵活配置","slug":"开发、测试、生产环境的灵活配置","date":"2019-11-15T16:00:00.000Z","updated":"2020-06-15T01:11:05.332Z","comments":true,"path":"2019/11/16/开发、测试、生产环境的灵活配置/","link":"","permalink":"https://liweipeng88.github.io/2019/11/16/%E5%BC%80%E5%8F%91%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E7%81%B5%E6%B4%BB%E9%85%8D%E7%BD%AE/","excerpt":"","text":"12345678910111213const BASE_URL_DEV = 'http://192.168.0.63:8080/sfFinace/'const BASE_URL_TEST = 'http://192.168.0.63:8080/sfFinace/'const BASE_URL_PRO = 'http://192.168.0.63:8080/sfFinace/'const MODE_TYPE = &#123; DEV : 0, TEST: 1, PRO: 2&#125;const MODE = MODE_TYPE.DEVexport const BASE_URL = [BASE_URL_DEV, BASE_URL_TEST, BASE_URL_PRO][MODE]","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"web前端/vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"数据结构转换.js","slug":"数据结构转换","date":"2019-10-21T16:00:00.000Z","updated":"2020-06-19T03:08:41.585Z","comments":true,"path":"2019/10/22/数据结构转换/","link":"","permalink":"https://liweipeng88.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"123456789101112let protypeidList = []//将this.addForm.ptlist数组中的元素最后一个值取到，追加到新的数组protypeidList中this.addForm.ptlist.forEach(r =&gt; &#123; let id = r[r.length - 1] protypeidList.push(id)&#125;)//将ptlist数组遍历后取到值，再为每个值添加属性名后追到新的数组中let ptlist = []protypeidList.map(v =&gt; ptlist.push(&#123; protypeid: v&#125;))console.log(ptlist);","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"}],"author":"Li Weipeng"},{"title":"runtime.js","slug":"微信小程序es7转es5的runtime.js库","date":"2019-09-10T16:00:00.000Z","updated":"2020-06-10T08:25:49.628Z","comments":true,"path":"2019/09/11/微信小程序es7转es5的runtime.js库/","link":"","permalink":"https://liweipeng88.github.io/2019/09/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fes7%E8%BD%ACes5%E7%9A%84runtime.js%E5%BA%93/","excerpt":"","text":"1.在小程序的开发工具中，勾选es6转es5语法 2.下载Facebook的regenerator库中的regenerator/blob/master/packages/regenerator-runtime/runtime.js 3.在小程序目录下新建文件夹lib/runtime/runtime.js，将代码拷贝进去 4.在每个需要使用async语法的页面js文件中，都引入（不能全局引入） runtime.js链接地址 引用方式：importregeneratorRuntimefrom’../../lib/runtime/runtime’ 备注：只引用即可，就可以使用 async 加 await","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"插件","slug":"web前端/插件","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://liweipeng88.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Li Weipeng"},{"title":"移动端简单的适配处理","slug":"移动端简单的适配","date":"2019-07-12T16:00:00.000Z","updated":"2020-06-18T07:49:24.661Z","comments":true,"path":"2019/07/13/移动端简单的适配/","link":"","permalink":"https://liweipeng88.github.io/2019/07/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%82%E9%85%8D/","excerpt":"","text":"123456789101112131415161718192021 (function () &#123; // 在标准 375px 适配下，16px = 1rem; var baseFontSize = 16; var baseWidth = 375; var set = function () &#123; var clientWidth = document.documentElement.clientWidth || window.innerWidth; var rem = 16; if (clientWidth != baseWidth) &#123; rem = Math.floor(clientWidth / baseWidth * baseFontSize); &#125; document.querySelector('html').style.fontSize = rem + 'px'; &#125; set(); window.addEventListener('resize', set); &#125;());&lt;/script&gt; vscode编码的情况下，安装cssrem插件，将基准转换值设为16px，这样就可以正常用rem作为单位开发","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"移动端","slug":"web前端/移动端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://liweipeng88.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"author":"Li Weipeng"},{"title":"moment.js的方法总结","slug":"moment.js的方法总结","date":"2018-11-03T16:00:00.000Z","updated":"2020-06-10T08:24:54.146Z","comments":true,"path":"2018/11/04/moment.js的方法总结/","link":"","permalink":"https://liweipeng88.github.io/2018/11/04/moment.js%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"总结一个非常实用的日期工具类moment.js，日期获取，格式化等。 都是以前工作中遇到的，我会在使用工具类的时候新建一个js，工作中遇到要显示什么都在这个文件里尝试，所以这个顺序是我工作中遇到然后在js文件中尝试的顺序，可能顺序稍微乱一些，但是大致没有什么问题。 引入moment12345//require 方式var moment=require('moment');//import 方式import moment from 'moment'; 设定moment区域为中国123456//require 方式require('moment/locale/zh-cn')moment.locale('zh-cn'); //import 方式import 'moment/locale/zh-cn'moment.locale('zh-cn'); 格式化时间类型1.取当天时间，以YYYY年MM月DD日形式显示 1var now=moment().format(\"YYYY年MM月DD日\"); 2.任意时间戳格式化，以YYYY-MM-DD HH:mm:ss形式显示 1var t1=moment(1411641720000).format('YYYY-MM-DD HH:mm:ss'); 获取前一天日期，格式以YYYY-MM-DD形式显示1var t11=moment().day(0).format('YYYY-MM-DD'); 获取本周五日期，格式以YYYY-MM-DD形式显示1var t12=moment().weekday(5).format('YYYY-MM-DD'); 获取上周五日期，格式以YYYY-MM-DD形式显示1var t13=moment().weekday(-3).format('YYYY-MM-DD'); 可以简单理解为上周倒数第几天，上周倒数第三天就是上周五了，和当天日期无关 获取当前年份、月份、日期123var t14=moment().year()var t15=moment().month()//此处月份从0开始，当前月要+1var t16=moment().date(); 注意这个地方，日期不是.day()/days() 结合t14，t15，t16就可以输出你想要的任何和当前日期、月份相关的日期 例如：我想获取去年今天的完整日期，如：今天是2018-7-23，我要输出的是2017-7-23 1console.log(`$&#123;t14-1&#125;-$&#123;t15+1&#125;-$&#123;t16&#125;`) 当然这不是获取去年今天日期最好的办法，但你可以拼出很多你想要的组合，下面会介绍更好的获取去年今日的方法。 获取上个月今天的日期，格式以YYYY-MM-DD显示1var t18=moment().subtract(1, 'months').format('YYYY-MM-DD'); 获取上个月日期，格式以YYYY-MM显示1var t19=moment().subtract(1, 'months').format('YYYY-MM') 获取前一天日期，格式以YYYY-MM-DD显示1var t20 = moment().subtract(1, 'days').format('YYYY-MM-DD'); 获取去年今天的日期，格式以YYYY-MM-DD显示，即简便的获取去年今天日期的方法1var t21= moment().subtract(1, 'year').format('YYYY-MM-DD'); 获取两个小时之后的时间1var t22=moment().add(2,'hours').format('YYYY-MM-DD HH:mm:ss'); 这个的应用是获取时间戳过期时间 比较也很简单，只要获取当前时间，一样的format用&gt;&lt;=号比较就可以了 获取五天前的日期例如:今天2018-7-23，获取到的时间是2018-7-18 1var t23=moment().subtract(5, 'days').format('YYYY-MM-DD');","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"插件","slug":"web前端/插件","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"常用插件","slug":"常用插件","permalink":"https://liweipeng88.github.io/tags/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"}],"author":"Li Weipeng"}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"UI库","slug":"web前端/UI库","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/UI%E5%BA%93/"},{"name":"Vue学习","slug":"web前端/Vue学习","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"},{"name":"nodejs","slug":"web前端/nodejs","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/nodejs/"},{"name":"vue","slug":"web前端/vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/vue/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"},{"name":"插件","slug":"web前端/插件","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6/"},{"name":"移动端","slug":"web前端/移动端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"UI库","slug":"UI库","permalink":"https://liweipeng88.github.io/tags/UI%E5%BA%93/"},{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"},{"name":"nodejs","slug":"nodejs","permalink":"https://liweipeng88.github.io/tags/nodejs/"},{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"},{"name":"小程序","slug":"小程序","permalink":"https://liweipeng88.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"移动端","slug":"移动端","permalink":"https://liweipeng88.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"常用插件","slug":"常用插件","permalink":"https://liweipeng88.github.io/tags/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"}]}