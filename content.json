{"meta":{"title":"李伟朋@博客","subtitle":"Today's pay, tomorrow's harvest","description":"Today's pay, tomorrow's harvest","author":"liweipeng","url":"https://liweipeng88.github.io","root":"/"},"pages":[{"title":"","date":"2020-12-17T01:15:04.115Z","updated":"2020-12-17T01:15:04.115Z","comments":true,"path":"404.html","permalink":"https://liweipeng88.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2020-03-14T16:00:00.000Z","updated":"2020-08-07T09:44:02.886Z","comments":true,"path":"about/index.html","permalink":"https://liweipeng88.github.io/about/index.html","excerpt":"","text":"1. 基本信息 姓名 电话 毕业院校 学历 邮箱 工作经验 李伟朋 15769294114 西安电子科技大学 大专 liweipeng_it@163.com 3 年以上 Github：https://github.com/LiWeipeng88 2. 求职意向工作地点：西安 期望职位：Web 前端工程师 3. 个人能力 能熟练使用前端开发工具Visual Studio Code、Photoshop 、FTP 熟练掌握HTML5和CSS3、Sass、熟悉PC端与移动端页面架构和布局。 掌握JavaScript脚本语言及jQuery、Swiper、Common js、Iconfonts等Js类库，应用JavaScript或jQuery等实现页面动态效果以及交互效果 熟练掌握VUE 框架以及VUE全家桶(Vue+Vue-router+Vuex+Axios+Webpack）等第三方插件，ElementUI，Mint-ui 等组件库，了解ES6、TypeScript语法。 熟悉Node.js开发，能够使用Nodejs和Express、Mongodb实现服务器端功能，访问数据库 4. 项目经验项目名称： 财务综合服务平台 项目简介：集项目预算（预算模板，预算通知）、项目报销（差旅报销，日常报销）以及系统设置（权限分配、流程设置）和基础信息（部门、项目、人事、职务）的综合服务平台。 我的职责：项目前端架构及技术选型，与后端沟通数据结构和Api接口的设计，前后端接口联调，部署服务器。 项目名称： 古城张记 www.xazhangji.com 项目简介：项目为西安古城张记美食公司所制作的官方网站，该项目已美食为主，突出特色食品，各种档次的快餐食品汇聚于此，公司主要以此网站宣传公司品牌，打造中国餐饮业的中国梦。 我的职责：负责UI界面设计，网页样式、动态效果的实现网站备案及域名解析 项目名称： 柒個秋天（微信小程序） 项目简介：项目是一个线上团购的社区销售商品的小程序，主要有商品秒杀、商品展示、线上下单、个人中心、商品兑换等为一体的社区团购平台。 我的职责：根据客户需求与后端，UI共同沟通界面设计和数据结构，项目架构及开发及测试发布。 项目名称： 库存管理系统 项目简介：针对前台项目的业务逻辑处理，实现库存管理、添加、修改、删除的功能；用户管理的注册、登录；对各个库存的统计以及按年、按周统计。对库存的管理有便捷的方式。 我的职责：根据业务需求选择技术框架和项目功能的梳理以及数据结构的设计完成开发。 5.工作经历2019年10月~至今 西安纳学电子科技有限责任公司 职位：WEB前端开发工程师 工作内容：从产品需求确定到技术架构总体参与，完成项目开发及后台数据对接，BUG测试及项目部署。参与产品功能设计，布局及页面优化兼容性处理。与后端配合完成产品需求及功能设计，配合UI 完成页面设计功能制定。项目持续跟进及客户使用反馈，优化产品易用性。 2017年3月~2019年9月 陕西奥度信息技术有限公司 职位：WEB前端开发工程师 工作内容：网站设计、UI设计、网站维护、PC前端开发和移动端开发与调试，小程序开发代，SEO优化，网站维护，图片设计，网站备案及域名解析。 6.教育经历 学校名称 学习时间 学历 专业 西安电子科技大学 2020.8 大专 软件技术"},{"title":"yourdiy","date":"2020-06-10T02:01:14.000Z","updated":"2020-06-10T02:01:14.459Z","comments":true,"path":"yourdiy/index-1.html","permalink":"https://liweipeng88.github.io/yourdiy/index-1.html","excerpt":"","text":""},{"title":"yourdiy","date":"2020-06-09T09:21:47.000Z","updated":"2020-06-09T09:21:47.346Z","comments":true,"path":"yourdiy/index.html","permalink":"https://liweipeng88.github.io/yourdiy/index.html","excerpt":"","text":""}],"posts":[{"title":"vue公共组件的封装","slug":"vue公共组件的封装","date":"2020-11-15T16:00:00.000Z","updated":"2020-11-16T02:32:36.012Z","comments":true,"path":"2020/11/16/vue公共组件的封装/","link":"","permalink":"https://liweipeng88.github.io/2020/11/16/vue%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"第一步：src下新建toast文件夹，创建index.js和toast.vue文件1234567891011121314151617181920212223//index.jsimport Toasts from './Toast'const Toast = &#123; install: function (Vue) &#123; // 创建一个Vue的“子类”组件 const ToastConstructor = Vue.extend(Toasts) // 创建一个该子类的实例,并挂载到一个元素上 const instance = new ToastConstructor() // 将这个实例挂载到动态创建的元素上,并将元素添加到全局结构中 instance.$mount(document.createElement('div')) document.body.appendChild(instance.$el) // 在Vue的原型链上注册方法，控制组件 Vue.prototype.$toast = (msg, duration = 5000) =&gt; &#123; instance.message = msg instance.isShow = true setTimeout(() =&gt; &#123; instance.isShow = false &#125;, duration) &#125; &#125;&#125;export default Toast 第二步：toast的写入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//toast.vue&lt;template&gt; &lt;transition name=\"fade\"&gt; &lt;div class=\"toast\" v-if=\"isShow\"&gt; &lt;i class=\"el-icon-info\" style=\"margin-right: 8px; color: #666666\"&gt;&lt;/i&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Toast', data() &#123; return &#123; message: '', isShow: false &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.toast &#123; padding: 5px 20px; color: #fff; background:rgba(0,0,0,.5); border: 1px solid #fff; text-align: center; position: fixed; font-size: 14px; border-radius: 5px; height: 36px; line-height: 36px; top: 30%; left: 50%; transform: translate(-50%, -50%);&#125;/* vue动画过渡效果设置 */.fade-enter-active,.fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125;&lt;/style&gt; 第三步：main.JS的配置12import Toast from \"@/common/toast\"Vue.use(Toast) 第四步：在使用的页面中1this.$toast('当前企业暂未入驻铁铁工业品超市')","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"}],"author":"Li Weipeng"},{"title":"vue项目中打印页面","slug":"vue项目中打印页面","date":"2020-08-12T16:00:00.000Z","updated":"2020-08-17T04:23:29.700Z","comments":true,"path":"2020/08/13/vue项目中打印页面/","link":"","permalink":"https://liweipeng88.github.io/2020/08/13/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%93%E5%8D%B0%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"1.将要打印的视图源码包裹在section标签中 1&lt;section ref=\"print\" class=\"recordImg\" id=\"printRecord\"&gt;&lt;/setion&gt; 2.在utils文件中创建print.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// 打印类属性、方法定义/* eslint-disable */const Print = function (dom, options) &#123; if (!(this instanceof Print)) return new Print(dom, options); this.options = this.extend(&#123; 'noPrint': '.no-print' &#125;, options); if ((typeof dom) === \"string\") &#123; this.dom = document.querySelector(dom); &#125; else &#123; this.isDOM(dom) this.dom = this.isDOM(dom) ? dom : dom.$el; &#125; this.init();&#125;;Print.prototype = &#123; init: function () &#123; var content = this.getStyle() + this.getHtml(); this.writeIframe(content); &#125;, extend: function (obj, obj2) &#123; for (var k in obj2) &#123; obj[k] = obj2[k]; &#125; return obj; &#125;, getStyle: function () &#123; var str = \"\", styles = document.querySelectorAll('style,link'); for (var i = 0; i &lt; styles.length; i++) &#123; str += styles[i].outerHTML; &#125; str += \"&lt;style&gt;\" + (this.options.noPrint ? this.options.noPrint : '.no-print') + \"&#123;display:none;&#125;&lt;/style&gt;\"; return str; &#125;, getHtml: function () &#123; var inputs = document.querySelectorAll('input'); var textareas = document.querySelectorAll('textarea'); var selects = document.querySelectorAll('select'); for (var k = 0; k &lt; inputs.length; k++) &#123; if (inputs[k].type == \"checkbox\" || inputs[k].type == \"radio\") &#123; if (inputs[k].checked == true) &#123; inputs[k].setAttribute('checked', \"checked\") &#125; else &#123; inputs[k].removeAttribute('checked') &#125; &#125; else if (inputs[k].type == \"text\") &#123; inputs[k].setAttribute('value', inputs[k].value) &#125; else &#123; inputs[k].setAttribute('value', inputs[k].value) &#125; &#125; for (var k2 = 0; k2 &lt; textareas.length; k2++) &#123; if (textareas[k2].type == 'textarea') &#123; textareas[k2].innerHTML = textareas[k2].value &#125; &#125; for (var k3 = 0; k3 &lt; selects.length; k3++) &#123; if (selects[k3].type == 'select-one') &#123; var child = selects[k3].children; for (var i in child) &#123; if (child[i].tagName == 'OPTION') &#123; if (child[i].selected == true) &#123; child[i].setAttribute('selected', \"selected\") &#125; else &#123; child[i].removeAttribute('selected') &#125; &#125; &#125; &#125; &#125; return this.dom.outerHTML; &#125;, writeIframe: function (content) &#123; var w, doc, iframe = document.createElement('iframe'), f = document.body.appendChild(iframe); iframe.id = \"myIframe\"; //iframe.style = \"position:absolute;width:0;height:0;top:-10px;left:-10px;\"; iframe.setAttribute('style', 'position:absolute;width:0;height:0;top:-10px;left:-10px;'); w = f.contentWindow || f.contentDocument; doc = f.contentDocument || f.contentWindow.document; doc.open(); doc.write(content); doc.close(); var _this = this iframe.onload = function () &#123; _this.toPrint(w); setTimeout(function () &#123; document.body.removeChild(iframe) &#125;, 100) &#125; &#125;, toPrint: function (frameWindow) &#123; try &#123; setTimeout(function () &#123; frameWindow.focus(); try &#123; if (!frameWindow.document.execCommand('print', false, null)) &#123; frameWindow.print(); &#125; &#125; catch (e) &#123; frameWindow.print(); &#125; frameWindow.close(); &#125;, 10); &#125; catch (err) &#123; console.log('err', err); &#125; &#125;, isDOM: (typeof HTMLElement === 'object') ? function (obj) &#123; return obj instanceof HTMLElement; &#125; : function (obj) &#123; return obj &amp;&amp; typeof obj === 'object' &amp;&amp; obj.nodeType === 1 &amp;&amp; typeof obj.nodeName === 'string'; &#125;&#125;;const MyPlugin = &#123;&#125;MyPlugin.install = function (Vue, options) &#123; // 4. 添加实例方法 Vue.prototype.$print = Print&#125;export default MyPlugin 3.将MyPlugin方法挂在到Vue原型上 12import print from '../utils/print'Vue.use(print) 4.定义事件方法 123PrintRow(index, row) &#123; this.$print(this.$refs.print) // 使用 &#125;,","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"web前端/Vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://liweipeng88.github.io/tags/VUE/"}],"author":"Li Weipeng"},{"title":"Echarts 中文 API说明文档","slug":"Echarts 中文 API说明文档","date":"2020-07-28T16:00:00.000Z","updated":"2020-08-07T09:36:04.371Z","comments":true,"path":"2020/07/29/Echarts 中文 API说明文档/","link":"","permalink":"https://liweipeng88.github.io/2020/07/29/Echarts%20%E4%B8%AD%E6%96%87%20API%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/","excerpt":"","text":"[官网链接](http://echarts.baidu.com/echarts2/doc/example/themeDesigner.htmlhttps://www.echartsjs.com/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754theme = &#123; // 全图默认背景 // backgroundColor: 'rgba(0,0,0,0)', // 默认色板 color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed', '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0', '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700', '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'], // 图表标题 title: &#123; x: 'left', // 水平安放位置，默认为左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: &#123; fontSize: 18, fontWeight: 'bolder', color: '#333' // 主标题文字颜色 &#125;, subtextStyle: &#123; color: '#aaa' // 副标题文字颜色 &#125; &#125;, // 图例 legend: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'center', // 水平安放位置，默认为全图居中，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: &#123; color: '#333' // 图例文字颜色 &#125; &#125;, // 值域 dataRange: &#123; orient: 'vertical', // 布局方式，默认为垂直布局，可选为： // 'horizontal' ¦ 'vertical' x: 'left', // 水平安放位置，默认为全图左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'bottom', // 垂直安放位置，默认为全图底部，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:['#1e90ff','#f0ffff'],//颜色 //text:['高','低'], // 文本，默认为数值文本 textStyle: &#123; color: '#333' // 值域文字颜色 &#125; &#125;, toolbox: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'right', // 水平安放位置，默认为全图右对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ &#123;number&#125;（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ &#123;number&#125;（y坐标，单位px） color : ['#1e90ff','#22bb22','#4b0082','#d2691e'], backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色 borderColor: '#ccc', // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : &#123;&#125;, // 自定义图片icon featureTitle : &#123; mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线', dataZoom : '区域缩放', dataZoomReset : '区域缩放后退', dataView : '数据视图', lineChart : '折线图切换', barChart : '柱形图切换', restore : '还原', saveAsImage : '保存为图片' &#125; &#125;, // 提示框 tooltip: &#123; trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis' showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: '#333', // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : &#123; // 坐标轴指示器，坐标轴触发有效 type : 'line', // 默认为直线，可选为：'line' | 'shadow' lineStyle : &#123; // 直线指示器样式设置 color: '#48b', width: 2, type: 'solid' &#125;, shadowStyle : &#123; // 阴影指示器样式设置 width: 'auto', // 阴影大小 color: 'rgba(150,150,150,0.3)' // 阴影颜色 &#125; &#125;, textStyle: &#123; color: '#fff' &#125; &#125;, // 区域缩放控制器 dataZoom: &#123; orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' // x: &#123;number&#125;, // 水平安放位置，默认为根据grid参数适配，可选为： // &#123;number&#125;（x坐标，单位px） // y: &#123;number&#125;, // 垂直安放位置，默认为根据grid参数适配，可选为： // &#123;number&#125;（y坐标，单位px） // width: &#123;number&#125;, // 指定宽度，横向布局时默认为根据grid参数适配 // height: &#123;number&#125;, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: 'rgba(0,0,0,0)', // 背景颜色 dataBackgroundColor: '#eee', // 数据背景颜色 fillerColor: 'rgba(144,197,237,0.2)', // 填充颜色 handleColor: 'rgba(70,130,180,0.8)' // 手柄颜色 &#125;, // 网格 grid: &#123; x: 80, y: 60, x2: 80, y2: 60, // width: &#123;totalWidth&#125; - x - x2, // height: &#123;totalHeight&#125; - y - y2, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' &#125;, // 类目轴 categoryAxis: &#123; position: 'bottom', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' &#125; &#125;, axisTick: &#123; // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: 'auto', // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#333', width: 1 &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: true, interval: 'auto', rotate: 0, margin: 8, // formatter: null, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitLine: &#123; // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: &#123; // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' &#125; &#125;, splitArea: &#123; // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: &#123; // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125; &#125;, // 数值型坐标轴默认参数 valueAxis: &#123; position: 'left', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' nameTextStyle: &#123;&#125;, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' &#125; &#125;, axisTick: &#123; // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#333', width: 1 &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitLine: &#123; // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' &#125; &#125;, splitArea: &#123; // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: &#123; // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125; &#125;, polar : &#123; center : ['50%', '50%'], // 默认全局居中 radius : '75%', startAngle : 90, splitNumber : 5, name : &#123; show: true, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, axisLine: &#123; // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: &#123; // 属性lineStyle控制线条样式 color: '#ccc', width: 1, type: 'solid' &#125; &#125;, axisLabel: &#123; // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: &#123; // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, splitArea : &#123; show : true, areaStyle : &#123; color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] &#125; &#125;, splitLine : &#123; show : true, lineStyle : &#123; width : 1, color : '#ccc' &#125; &#125; &#125;, // 柱形图默认参数 bar: &#123; barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: '30%', // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : '20%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: &#123; normal: &#123; // color: '各异', barBorderColor: '#fff', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: '各异', barBorderColor: 'rgba(0,0,0,0)', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, // 折线图默认参数 line: &#123; itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle: &#123; width: 2, type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125;, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） &#125;, // K线图默认参数 k: &#123; // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: &#123; normal: &#123; color: '#fff', // 阳线填充颜色 color0: '#00aa11', // 阴线填充颜色 lineStyle: &#123; width: 1, color: '#ff3200', // 阳线边框颜色 color0: '#00aa11' // 阴线边框颜色 &#125; &#125;, emphasis: &#123; // color: 各异, // color0: 各异 &#125; &#125; &#125;, // 散点图默认参数 scatter: &#123; //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000,// 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: '各异' label: &#123; show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, // 雷达图默认参数 radar : &#123; itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false &#125;, lineStyle: &#123; width: 2, type: 'solid' &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false &#125; &#125; &#125;, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 &#125;, // 饼图默认参数 pie: &#123; center : ['50%', '50%'], // 默认全局居中 radius : [0, '75%'], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: &#123; normal: &#123; // color: 各异, borderColor: '#fff', borderWidth: 1, label: &#123; show: true, position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, labelLine: &#123; show: true, length: 20, lineStyle: &#123; // color: 各异, width: 1, type: 'solid' &#125; &#125; &#125;, emphasis: &#123; // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, label: &#123; show: false // position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, labelLine: &#123; show: false, length: 20, lineStyle: &#123; // color: 各异, width: 1, type: 'solid' &#125; &#125; &#125; &#125; &#125;, map: &#123; mapType: 'china', // 各省的mapType暂时都用中文 mapLocation: &#123; x : 'center', y : 'center' // width // 自适应 // height // 自适应 &#125;, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: &#123; normal: &#123; // color: 各异, borderColor: '#fff', borderWidth: 1, areaStyle: &#123; color: '#ccc'//rgba(135,206,250,0.8) &#125;, label: &#123; show: false, textStyle: &#123; color: 'rgba(139,69,19,1)' &#125; &#125; &#125;, emphasis: &#123; // 也是选中样式 // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, areaStyle: &#123; color: 'rgba(255,215,0,0.8)' &#125;, label: &#123; show: false, textStyle: &#123; color: 'rgba(139,69,19,1)' &#125; &#125; &#125; &#125; &#125;, force : &#123; // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: &#123; normal: &#123; // color: 各异, label: &#123; show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, nodeStyle : &#123; brushType : 'both', color : '#f08c2e', strokeColor : '#5182ab' &#125;, linkStyle : &#123; strokeColor : '#5182ab' &#125; &#125;, emphasis: &#123; // color: 各异, label: &#123; show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, nodeStyle : &#123;&#125;, linkStyle : &#123;&#125; &#125; &#125; &#125;, chord : &#123; radius : ['65%', '75%'], center : ['50%', '50%'], padding : 2, sort : 'none', // can be 'none', 'ascending', 'descending' sortSub : 'none', // can be 'none', 'ascending', 'descending' startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : &#123; normal : &#123; label : &#123; show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle : &#123; width : 0, color : '#000' &#125;, chordStyle : &#123; lineStyle : &#123; width : 1, color : '#666' &#125; &#125; &#125;, emphasis : &#123; lineStyle : &#123; width : 0, color : '#000' &#125;, chordStyle : &#123; lineStyle : &#123; width : 2, color : '#333' &#125; &#125; &#125; &#125; &#125;, island: &#123; r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% &#125;, markPoint : &#123; symbol: 'pin', // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: &#123; normal: &#123; // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: &#123; show: true, position: 'inside' // 可选为'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125;, emphasis: &#123; // color: 各异 label: &#123; show: true // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125; &#125; &#125; &#125;, markLine : &#123; // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: ['circle', 'arrow'], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: &#123; normal: &#123; // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: &#123; show: false, // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom' position: 'inside', textStyle: &#123; // 默认使用全局文本样式，详见TEXTSTYLE color: '#333' &#125; &#125;, lineStyle: &#123; // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 &#125; &#125;, emphasis: &#123; // color: 各异 label: &#123; show: false // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE &#125;, lineStyle : &#123;&#125; &#125; &#125; &#125;, textStyle: &#123; decoration: 'none', fontFamily: 'Arial, Verdana, sans-serif', fontFamily2: '微软雅黑', // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' &#125;, // 默认标志图形类型列表 symbolList : [ 'circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond' ], loadingText : 'Loading...', // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色 calculableHolderColor: '#ccc', // 可计算占位提示颜色 nameConnector: ' &amp; ', valueConnector: ' : ', animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: 'ExponentialOut' //BounceOut&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Echarts","slug":"web前端/Echarts","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Echarts/"}],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://liweipeng88.github.io/tags/Echarts/"}],"author":"Li Weipeng"},{"title":"web通讯的四种方式","slug":"web通讯的四种方式，短轮询、长轮询(comet)、长连接(SSE)、WebSocket","date":"2020-06-20T16:00:00.000Z","updated":"2020-08-17T09:23:27.148Z","comments":true,"path":"2020/06/21/web通讯的四种方式，短轮询、长轮询(comet)、长连接(SSE)、WebSocket/","link":"","permalink":"https://liweipeng88.github.io/2020/06/21/web%E9%80%9A%E8%AE%AF%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2(comet)%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5(SSE)%E3%80%81WebSocket/","excerpt":"","text":"一 短轮询1.1 定义http端轮询是服务器收到请求不管是否有数据都直接响应 http 请求;其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。 1.2 应用场景传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。 1.3 优点前后端程序编写比较容易。 1.4 缺点 请求中有大半是无用，难于维护，浪费带宽和服务器资源； 响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。 1.5 实例：适于小型应用。1.6 前端实现：12345678var xhr = new XMLHttpRequest(); setInterval(function()&#123; xhr.open('GET','/user'); xhr.onreadystatechange = function()&#123; &#125;; xhr.send(); &#125;,1000) 二 长轮询2.1 定义客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 2.2 优点在无消息的情况下不会频繁的请求，耗费资源小。 2.3 缺点 服务器hold连接会消耗资源 返回数据顺序无保证，难于管理维护。 浏览器端对统一服务器同时 http 连接有最大限制, 最好同一用户只存在一个长轮询; 2.4 实例：WebQQ、Hi网页版、Facebook IM。2.5 前端实现：12345678function ajax()&#123; var xhr = new XMLHttpRequest(); xhr.open('GET','/user'); xhr.onreadystatechange = function()&#123; ajax(); &#125;; xhr.send(); &#125; 长轮训和短轮训相同点： 可以看出 http 长轮询和 http 短轮询的都会 hold 一段时间; 不同点 间隔发生在服务端还是浏览器端: http 长轮询在服务端会 hold 一段时间, http 短轮询在浏览器端 “hold”一段时间; 三 http 长连接目前 http 协议普遍使用的是 1.1 版本, 之前有个 1.0 版本,两者之间的一个区别是 1.1 支持 http 长连接, 或者叫持久连接。1.0 不支持 http 长连接, 每次一个 http请求响应后都关闭 tcp 连接, 下个 http 请求会重新建立 tcp 连接. 3.1定义多个 http 请求共用一个 tcp 连接; 这样可以减少多次临近 http 请求导致 tcp建立关闭所产生的时间消耗. http 1.1 中在请求头和相应头中用 connection字段标识是否是 http长连接, connection: keep-alive, 表明是 http 长连接; connection:closed, 表明服务器关闭 tcp 连接 与 connection 对应的一个字段是 keep-live, http 响应头中出现, 他的格式是 timeout=30,max=5, timeout 是两次 http 请求保持的时间(s), , max 是这个 tcp 连接最多为几个 http请求重用 3.2优点消息即时到达，不发无用请求；管理起来也相对方便。 3.3 缺点服务器维护一个长连接会增加开销。 3.4实例：Gmail聊天四 Web Socket4.1定义Websocket是基于HTTP协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。 4.2优点请求响应快，不浪费资源。（传统的http请求，其并发能力都是依赖同时发起多个TCP连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升；http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket则因为复用长连接而没有这一问题。） 4.3缺点： 主流浏览器支持的Web Socket版本不一致； 服务端没有标准的API。 4.4实例：实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询4.5 解决：解决了http协议的两个问题。 1.服务端的被动性。http协议是只有客户端询问之后才回复。解决了同步有延迟的问题 2.解决了服务器上消耗资源的问题 4.6 实现：123456789101112131415161718192021222324252627282930313233343536//需要先npm install ws //服务器端var Server = require('ws').Server;var wss = new Server(&#123; port:2000&#125;);wss.on('connection',function(ws)&#123; ws.on('message',function(data)&#123; ws.send('你好,客户端,我是服务器!'); console.log(data); &#125;)&#125;); //node客户端 var WebSocket = require('ws');var socket = new WebSocket('ws://localhost:2000/');socket.on('open',function()&#123; socket.send('你好，服务器,我是客户端');&#125;);socket.on('message',function(event)&#123; console.log(event);&#125;) //html客户端(注:浏览器客户端与node客户端只需要一种) &lt;script&gt; var socket = new WebSocket('ws://localhost:2000/'); socket.onopen = function()&#123; &#125;; socket.onmessage = function(event)&#123; console.log(event.data) &#125;&lt;/script&gt; 4.7 WebSocket四个事件操作 onmessage收到服务器响应时执行 onerroe 出现异常时执行 onopen 建立起连接时执行 onclose 断开连接时执行 1234567891011121314151617181920212223242526272829303132333435363738394041websocket = null; url=\"127.xxxxxxx/xxx\" var websocketAddress = 'ws://'+ url ;//判断当前浏览器是否支持WebSocket if('WebSocket' in window)&#123; websocket = new WebSocket(websocketAddress); &#125; else&#123; alert('当前浏览器不支持WebSocket') &#125; //连接发生错误的回调方法 websocket.onerror = function()&#123; //notificationReminder(\"错误\"); &#125;; //连接成功时的回调方法 websocket.onopen = function(event)&#123; console.log(event); &#125; //接收到消息的回调方法 websocket.onmessage = function(event)&#123; $scope.notificationReminder(event.data); &#125; //连接关闭的回调方法 websocket.onclose = function()&#123; //notificationReminder(\"关闭\"); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; websocket.close(); &#125; //发送消息 $scope.send = function()&#123; websocket.send(localStorageService.get('UserID')); &#125; $scope.closeWebSocket = function()&#123; websocket.close(); &#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"}],"author":"Li Weipeng"},{"title":"Vue项目跳转请求数据窗口上方的进度条显示","slug":"Vue项目跳转进度条显示","date":"2020-06-05T16:00:00.000Z","updated":"2020-07-22T02:52:45.922Z","comments":true,"path":"2020/06/06/Vue项目跳转进度条显示/","link":"","permalink":"https://liweipeng88.github.io/2020/06/06/Vue%E9%A1%B9%E7%9B%AE%E8%B7%B3%E8%BD%AC%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%98%BE%E7%A4%BA/","excerpt":"","text":"1.安装： 1cnpm install --save nprogress 2.在main.js中引入： 121 import NProgress from &#39;nprogress&#39;2 import &#39;nprogress&#x2F;nprogress.css&#39; 3.在main.js中进行配置： 12345671 NProgress.configure(&#123; 2 easing: &#39;ease&#39;, &#x2F;&#x2F; 动画方式 3 speed: 500, &#x2F;&#x2F; 递增进度条的速度 4 showSpinner: false, &#x2F;&#x2F; 是否显示加载ico 5 trickleSpeed: 200, &#x2F;&#x2F; 自动递增间隔 6 minimum: 0.3 &#x2F;&#x2F; 初始化时的最小百分比7 &#125;) 4.在main.js中对路由钩子进行设置： 123456789101112 &#x2F;&#x2F;当路由进入前 router.beforeEach((to, from , next) &#x3D;&gt; &#123; &#x2F;&#x2F; 每次切换页面时，调用进度条 NProgress.start(); &#x2F;&#x2F; 这个一定要加，没有next()页面不会跳转的。这部分还不清楚的去翻一下官网就明白了 next(); &#125;);&#x2F;&#x2F;当路由进入后：关闭进度条router.afterEach(() &#x3D;&gt; &#123; &#x2F;&#x2F; 在即将进入新的页面组件前，关闭掉进度条 NProgress.done()&#125;) 5.通过 axios 拦截器来调用 1234567891011121314// axios 请求拦截器 发起请求就会触发axios.interceptors.request.use(config =&gt; &#123; // 发起请求则展示进度条 NProgress.start() // 必须要返回config return config;&#125;)// 请求有response后则触发axios.interceptors.response.use(config =&gt; &#123; // 请求结束则结束进度条 NProgress.done() // 必须要返回config return config&#125;)","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"web前端/vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"内网穿透的几种方式","slug":"内网穿透的几种方式","date":"2020-06-05T16:00:00.000Z","updated":"2020-07-22T02:39:46.871Z","comments":true,"path":"2020/06/06/内网穿透的几种方式/","link":"","permalink":"https://liweipeng88.github.io/2020/06/06/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"概述 如何让任何地方都能访问自己家里的笔记本上的应用？ 如何让局域网的服务器可以被任何地方访问到？ 有很多类似的需求，我们可以统一用一个解决方案：内网穿透。下面介绍几种内网穿透的方式，供大家学习和参考。每一种工具只要亲自试了都会更新成一篇文章，给出教程，没有试的会给简单的介绍和工具信息。 工具介绍 Ngrok Ssh、autossh Natapp Frp Lanproxy Spike 花生壳 Ngrok 项目主页：https://ngrok.com/ 项目介绍： 一个通过任何NAT或防火墙为您的本地主机服务器提供即时访问、安全的URL的命令。类似花生壳，分为服务端和客户端，也可以自己搭建服务端。 使用教程：点击跳转 Ssh配合autossh工具使用，因为autossh会容错 项目主页：http://www.harding.motd.ca/autossh/ 项目介绍：自动重新启动SSH会话和隧道。autossh是一个程序，用于启动ssh的副本并进行监控，在死亡或停止传输流量时根据需要重新启动它。 这个想法来自rstunnel（Reliable SSH Tunnel），但是在C中实现。作者的观点是，它不像匆匆忙忙的工作那么容易。使用端口转发环路或远程回显服务进行连接监视。在遇到连接拒绝等快速故障时，关闭连接尝试的速度。在OpenBSD，Linux，Solaris，Mac OS X，Cygwin和AIX上编译和测试; 应该在其他BSD上工作。免费软件。 使用教程：点击跳转 Natapp 项目主页：https://natapp.cn/ 项目介绍：基于ngrok的国内收费内网穿透工具，类似花生壳，有免费版本，比花生壳好。免费版本：提供http,https,tcp全隧道穿透，随机域名/TCP端口，不定时强制更换域名/端口，自定义本地端口 Frp 项目主页：https://github.com/fatedier/frp 项目介绍：frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。 Lanproxy 项目主页：https://github.com/ffay/lanproxy 项目介绍：lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。 Spike 项目主页：https://github.com/slince/spike 项目介绍：Spike是一个可以用来将你的内网服务暴露在公网的快速的反向代理，基于ReactPHP，采用IO多路复用模型。采用Php实现。 花生壳 项目主页：https://hsk.oray.com/ 项目介绍：商业化比较成功的内网穿透。个人开发很不推荐，收费贵，企业可以考虑使用。","categories":[{"name":"其他","slug":"其他","permalink":"https://liweipeng88.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"内网穿透","slug":"其他/内网穿透","permalink":"https://liweipeng88.github.io/categories/%E5%85%B6%E4%BB%96/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://liweipeng88.github.io/tags/%E5%85%B6%E4%BB%96/"}],"author":"Li Weipeng"},{"title":"浅谈前端八大UI库","slug":"浅谈前端八大UI库","date":"2020-05-15T16:00:00.000Z","updated":"2020-06-11T01:50:35.356Z","comments":true,"path":"2020/05/16/浅谈前端八大UI库/","link":"","permalink":"https://liweipeng88.github.io/2020/05/16/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%85%AB%E5%A4%A7UI%E5%BA%93/","excerpt":"","text":"1. Element-UI element-UI是现在基于Vue的一个非常好用的桌面端UI组件库 支持@vue/cli项目的直接添加，支持按需导入、国际化、支持自定义主题③文档清晰，学习成本低 提供的组件足够使用，UI的风格符合目前大众的普遍审美 如果你想要做一个公司级别的产品，那么Element-Ul基本可以满足需求，但是难免样式、风格会同质化严重 2. Vuetify vuetify是国外团队进行开发的一个基于vue的组件库 支持@vue/cli项目的直接添加，支持按需导入、国际化、提供了定制功能(样式、颜色、主题等等) 文档相对清晰，但是和国人的思维不太一样，导致学习成本相对高一些 提供的组件足够使用，并且提供了v-开头的扩展指令,还有付费专题模块 UI的风格使用的是Google推出的Material Design的设计风格,在国内推广度相对低一些 使用vuetify在UI样式上，会有- -些额外的风险,但是可以避免同质化的问题，比较适合些个人或者需要彰显个性的项目 3. Ant Design Ant Design是阿里巴巴-蚂蚁金服体验技术部所设计的- -个UI库, - -般用于基于React的项目 支持在create-react-app (React 官方脚手架)项目的直接添加， 支持按需导入、国际化、提供了定制主题 文档清晰，学习成本低，提供的组件足够使用，并且提供了精品社区服务 UI的风格符合目前大众的普遍审美 如果你想要做一个公司级别的产品， 那么Ant Design基本可以满足需求，但是难免样式、风格会同质化严重 6. Vant-UI Vant-UI是有赞前端团队所设计的一-个UI库, -般用于基于Vue的移动端项目 支持@vue/cli项目的直接添加，支持按需导入、国际化、提供了定制功能，(样式、颜色、主题等等) 文档清晰，学习成本低，UI的风格以及交互操作可以达到现在的主流标准 提供的组件足够使用，性能不错，并且提供了基于商城业务的成套组件 适用于web app或者基于移动端的网页开发 7. Framework7 Framework7是独立开发者所设计的一一个全功能框架。可以用来构建IOS. Android和桌面应用程序。 本身是一个独立的框架，同时也可以配合vue和react来使用。整体比较重 文档汉化不是很好，具有一定的学习成本。 提供的功能组件、交互视图足够强大,并且也有很多新的概念,性能优秀 UI 的风格以及交互操作可以达到原生APP 95%的体验 适用于没有资深前端开发工程师的公司使用。 8. WEUI weui是微信官方团队开发的一套同微信原生视觉体验一 致的基础样式库。 因为只应对微信内部网页和微信小程序，所以所提供的功能相对简单。 文档稍微乱-些。提供的功能组件有限，主要还是应对场景的问题。 提供的功能组件有限，主要还是应对场景的问题。 适用微信内部网页和微信小程序。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"UI库","slug":"web前端/UI库","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/UI%E5%BA%93/"}],"tags":[{"name":"UI库","slug":"UI库","permalink":"https://liweipeng88.github.io/tags/UI%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"express常用的中间件","slug":"express常用的中间件详细介绍","date":"2020-03-04T16:00:00.000Z","updated":"2020-07-22T02:04:22.040Z","comments":true,"path":"2020/03/05/express常用的中间件详细介绍/","link":"","permalink":"https://liweipeng88.github.io/2020/03/05/express%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"Express是一个自身功能极简，完全是有路由和中间件构成的一个web开发框架：本质上说，一个express的应用就是在调用各种中间件。 中间件的功能： 执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 如果在post，get请求过程中的回调函数没有next()参数，那么就匹配上第一个路由，就不会往下匹配了。如果想往下匹配的话，就需要写next(); Express 常用的中间件介绍1.应用级别的中间件1234app.use(function (req, res, next) &#123;/*表示匹配任何路由*/ console.log(new Date()) next()/*表示匹配完成这个中间件就继续往下执行。*/&#125;) 2.路由中间件1234567891011app.get(\"/\", function (req, res,next) &#123; console.log(\"匹配成功\"); next()&#125;)app.get(\"/\", function (req, res) &#123; var list = [1, 6, 9, 8, 55, 66, 45] res.render('index', &#123; \"list\": list &#125;)&#125;) 3.错误处理中间件（404页面也是属于其中的一种） 123app.use((req,res)=&gt;&#123; res.status(200).send(\"这个是404 没有路由匹配到！\")&#125; 4.内置中间件（例如：静态路由匹配）1app.use('/static',express.static(\"public\")); 5.第三方中间件post请求在express中是不能直接获取的，但是我们可以使用第三方中间件body-parser模块来获取。 123456789//第一步安装npm install body-parservar express = require('express')var bodyParser = require('body-parser')var app = express()// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())","categories":[{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"框架","slug":"后端/框架","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/tags/%E5%90%8E%E7%AB%AF/"}],"author":"Li Weipeng"},{"title":"根据地址栏输入的地址请求对应的接口数据","slug":"vue获取地址栏地址请求对应的接口请求 - 副本","date":"2020-03-04T16:00:00.000Z","updated":"2020-07-22T02:37:27.019Z","comments":true,"path":"2020/03/05/vue获取地址栏地址请求对应的接口请求 - 副本/","link":"","permalink":"https://liweipeng88.github.io/2020/03/05/vue%E8%8E%B7%E5%8F%96%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%9C%B0%E5%9D%80%E8%AF%B7%E6%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%20-%20%E5%89%AF%E6%9C%AC/","excerpt":"","text":"123456789// window.location.hostname 获取地址输入的地址if (window.location.hostname == '10.10.10.220') &#123; axios.defaults.baseURL = \"http://10.10.10.220:8111/sfFinace/\"; //服务器地址&#125; else if (window.location.hostname == '221.11.70.78') &#123; axios.defaults.baseURL = \"http://221.11.70.78:8111/sfFinace/\"; //服务器地址&#125; else if (window.location.hostname == '127.0.0.1' || window.location.hostname == 'localhost') &#123; axios.defaults.baseURL = \"http://192.168.0.63:8080/sfFinace/\"; //本地地址&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"}],"author":"Li Weipeng"},{"title":"请求接口的简单封装","slug":"nui-app里面的请求接口简单的封装","date":"2020-03-02T16:00:00.000Z","updated":"2020-07-08T01:38:47.796Z","comments":true,"path":"2020/03/03/nui-app里面的请求接口简单的封装/","link":"","permalink":"https://liweipeng88.github.io/2020/03/03/nui-app%E9%87%8C%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%81%E8%A3%85/","excerpt":"","text":"新建一个封装接口的文件12345678910111213141516171819202122232425const BASE_URL &#x3D; &#39;http:&#x2F;&#x2F;localhost:8082&#39;export const myRequest &#x3D; (options) &#x3D;&gt; &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; nui.request(&#123; url:BASE_URL + options.url, method: options.method || &#39;GET&#39;, data: options.data || &#123;&#125;, success: res &#x3D;&gt;&#123; if(res.data.status !&#x3D;&#x3D; 0)&#123; return nui.showToast(&#123; title:&#39;获取数据失败&#39; &#125;) &#125; resolve(res) &#125;, fail:(err) &#x3D;&gt;&#123; nui.showToast(&#123; title:&#39;请求接口失败&#39; &#125;) reject(err) &#125; &#125;) &#125;)&#125; 挂在到Vue原型上12345678910111213import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App&#39;import &#123; myRequest &#125; from &#39;.&#x2F;util&#x2F;api.js&#39;Vue.prototype.$myRequest &#x3D; myRequestVue.config.productionTip &#x3D; falseApp.mpType &#x3D; &#39;app&#39;const app &#x3D; new Vue(&#123; ...App&#125;)app.$mount() 要请求接口的页面12345678methods:&#123; async getSwipersList()&#123; const res &#x3D; await this.$myRequest(&#123; url:&#39;&#x2F;api&#x2F;getBanner&#39; &#125;) console.log(res) &#125; &#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Vue学习","slug":"web前端/Vue学习","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"MongoDB 数据库优化操作","slug":"MongoDB 数据库常用操作命令（四）","date":"2020-02-14T16:00:00.000Z","updated":"2020-07-22T01:53:29.331Z","comments":true,"path":"2020/02/15/MongoDB 数据库常用操作命令（四）/","link":"","permalink":"https://liweipeng88.github.io/2020/02/15/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"分片相关1234567891011121314151617181920212223242526272829db.runCommand(&#123; isdbgrid : 1&#125;); # 判断是否Shard集群# 列出所有分片信息use admin;db.runCommand(&#123; listshards : 1&#125;);# 列出开启分片的数据库use config;db.databases.find(&#123;\"partitioned\":true&#125;);db.databases.find(); # 列出所有数据库分片情况# 查看分片的片键use config;db.collections.find();# 删除片键use config;db.collections.remove(&#123;\"_id\":\"testdb.t_user\"&#125;);# 刷新mongos的缓存use admin;db.adminCommand(&#123;\"flushRouterConfig\":1&#125;);# 删除分片节点db.runCommand(&#123;removeShard:\"shard-2\"&#125;);# 其他db.getPrevError(); # 查询之前的错误信息db.resetError(); # 清除错误记录 索引123456789# 创建索引db.&lt;foo&gt;.ensureIndex(&#123;name: 1&#125;);db.&lt;foo&gt;.ensureIndex(&#123;name: 1, ts: -1&#125;);db.&lt;foo&gt;.getIndexes(); # 查询当前聚集集合所有索引db.&lt;foo&gt;.totalIndexSize(); # 查看总索引记录大小db.users.reIndex(); # 读取当前集合的所有index信息db.users.dropIndex(\"name_1\"); # 删除指定索引db.users.dropIndexes(); # 删除所有索引索引","categories":[{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"MongoDB","slug":"后端/MongoDB","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liweipeng88.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"MongoDB用户相关操作","slug":"MongoDB 数据库常用操作命令（三）","date":"2020-02-13T16:00:00.000Z","updated":"2020-07-22T01:49:38.953Z","comments":true,"path":"2020/02/14/MongoDB 数据库常用操作命令（三）/","link":"","permalink":"https://liweipeng88.github.io/2020/02/14/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"用户相关操作如果系统已经启动权限验证，必须使用拥有权限的账户登录操作。mongodb角色权限文档：https://docs.mongodb.com/v3.6/reference/built-in-roles/index.html 创建一个超级用户角色： 12345678use admin;db.createUser( &#123; user: &quot;admin&quot;, pwd: &quot;pwd123&quot;, roles: [ &quot;root&quot; ] &#125;); root角色为所有资源提供完全权限，相当于MySQL里的 root 账户。 在 testdb 数据库中创建一个 testuser 账户： 12345678use testdb;db.createUser( &#123; user: &quot;testuser&quot;, pwd: &quot;123456&quot;, roles: [ &#123; role: &quot;dbOwner&quot;, db: &quot;testdb&quot; &#125; ] &#125;); dbOwner代表数据库所有者，可以对数据库执行任何管理操作，包含readWrite、dbAdmin和userAdmin角色的权限。 在 admin 库中创建一个具有多个权限的账户： 1234567891011121314151617181920212223user admin;db.createUser( &#123; user: &quot;admin&quot;, pwd: &quot;123456&quot;, roles: [ &quot;userAdminAnyDatabase&quot;, &quot;dbAdminAnyDatabase&quot;, &quot;readWriteAnyDatabase&quot;] &#125;);show users; # 显示当前库所有用户db.getUser(&#39;admin&#39;); # 查看用户详情db.dropUser(&quot;admin&quot;); # 删除用户db.logout(); # 退出当前登录# 修改用户密码use testdb;db.updateUser(&quot;testuser&quot;, &#123;pwd: &quot;123456789&quot;&#125;);db.changeUserPassword(&quot;testuser&quot;, &quot;123456789&quot;);# 修改用户角色use testdb;db.updateUser( &quot;&lt;username&gt;&quot;, roles : [&#123; role: &quot;&quot;, db: &quot;&quot; &#125;]); 用户相关操作文档：https://docs.mongodb.com/manual/reference/method/js-user-management/ 连接数据库身份验证连接后身份验证： 123mongo --port 20000use admin;db.auth(&quot;testuser&quot;, &quot;123456&quot;); 连接时身份验证： 1mongo --port 27017 -u &quot;root&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot; 连接时身份验证，并进入指定库： 12mongo --port 20000 -u &quot;root&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot;mongo --port 20000 -u &quot;testuser&quot; -p &quot;123456&quot; --authenticationDatabase &quot;admin&quot; testdb 代码、客户端连接方式： 12mongodb:&#x2F;&#x2F;testuser:123456789@192.168.0.3:20000,192.168.0.4:20000,192.168.0.5:20000&#x2F;testdbmongodb:&#x2F;&#x2F;root:pwd123@192.168.0.3:20000,192.168.0.4:20000,192.168.0.5:20000&#x2F;admin","categories":[{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"MongoDB","slug":"后端/MongoDB","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liweipeng88.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"MongoDB 增删改查 集合数据","slug":"MongoDB 数据库常用操作命令（二）","date":"2020-02-12T16:00:00.000Z","updated":"2020-07-22T01:45:23.151Z","comments":true,"path":"2020/02/13/MongoDB 数据库常用操作命令（二）/","link":"","permalink":"https://liweipeng88.github.io/2020/02/13/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"增加在user集合添加数据，添加的数据的数据列，没有固定，根据添加的数据为准： 12db.users.save(&#123;name: 'zhangsan', age: 25, sex: true&#125;);for(var i=1;i&lt;=20000;i++) db.users.save(&#123;id:i, testkey:\"test_val_\"+i&#125;) 修改语法：db.collection.update(criteria, objNew, upsert, multi ) criteria查询条件，类似 sql update查询内where后面的。 objNewupdate 的对象和一些更新的操作符（如$,$inc…）等，可以理解为sql update查询内set后面的。 upsert如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入。 multi默认是false，只更新找到的第一条记录，如果这个参数为true，就把按条件查出来多条记录全部更新。 1234567891011db.users.update(&#123;age: 25&#125;, &#123;$set: &#123;name: 'changeName'&#125;&#125;, false, true);# 等于SQL：update users set name = 'changeName' where age = 25;db.users.update(&#123;name: 'Lisi'&#125;, &#123;$inc: &#123;age: 50&#125;&#125;, false, true);# 等于SQL：update users set age = age + 50 where name = 'Lisi';db.users.update(&#123;name: 'Lisi'&#125;, &#123;$inc: &#123;age: 50&#125;, $set: &#123;name: 'hoho'&#125;&#125;, false, true);# 等于SQL：update users set age = age + 50, name = 'hoho' where name = 'Lisi';# 更新 users 表里面 login == lxk 修改 email 字段为后面的那个值，false 表示如果不存在就不插入新数据；true 代表查询修改所有符合条件的数据：db.getCollection('users').update(&#123;\"login\" : \"lxk\"&#125;, &#123;$set: &#123;\"email\": 'sk@123.com'&#125;&#125;, false, true); 查询这里``表示一个集合（相当于MySQL的表）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# 查询所有记录，默认每页20条记录，输入 it 查看下一页：db.&lt;foo&gt;.find();# 等于SQL：select * from &lt;foo&gt;;# 去掉集合中 name 列的重复数据db.&lt;foo&gt;.distinct(\"name\");# 等于SQL：select distict name from &lt;foo&gt;;# 查询 id = 22 的记录db.&lt;foo&gt;.find(&#123;\"id\": 22&#125;);# 等于SQL：select * from &lt;foo&gt; where id = 22;# 查询 age &gt; 22 的记录db.&lt;foo&gt;.find(&#123;age: &#123;$gt: 22&#125;&#125;);# 等于SQL：select * from &lt;foo&gt; where age &gt; 22;# 查询 age &lt; 22 的记录db.&lt;foo&gt;.find(&#123;age: &#123;$lt: 22&#125;&#125;);# 等于SQL：select * from &lt;foo&gt; where age &lt; 22;# 查询 age &gt;= 25 的记录db.&lt;foo&gt;.find(&#123;age: &#123;$gte: 25&#125;&#125;);# 等于SQL：select * from &lt;foo&gt; where age &gt;= 25;# 查询 age &lt;= 25 的记录db.&lt;foo&gt;.find(&#123;age: &#123;$lte: 25&#125;&#125;);# 查询 age &gt;= 23 并且 age &lt;= 26db.&lt;foo&gt;.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;);# 查询 name 中包含 mongo 的数据db.&lt;foo&gt;.find(&#123;name: /mongo/&#125;);# 等于SQL：select * from &lt;foo&gt; where name like '%mongo%';# 查询 name 中以 mongo 开头的db.&lt;foo&gt;.find(&#123;name: /^mongo/&#125;);# 等于SQL：select * from &lt;foo&gt; where name like 'mongo%';#查询指定列 name、age 数据db.&lt;foo&gt;.find(&#123;&#125;, &#123;name: 1, age: 1&#125;);# 等于SQL：select name, age from &lt;foo&gt;;# 这里 1 可以写成 true，如果写成 false 表示排除此列# 查询指定列 name、age 数据, age &gt; 25db.&lt;foo&gt;.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;);# 等于SQL：select name, age from &lt;foo&gt; where age &gt; 25;# 按照年龄排序db.&lt;foo&gt;.find().sort(&#123;age: 1&#125;); # 升序db.&lt;foo&gt;.find().sort(&#123;age: -1&#125;); # 降序# 查询 name = zhangsan, age = 22 的数据db.&lt;foo&gt;.find(&#123;name: 'zhangsan', age: 22&#125;);# 等于SQL：select * from &lt;foo&gt; where name = 'zhangsan' and age = '22';# 查询前5条数据db.&lt;foo&gt;.find().limit(5);# 等于SQL：select top 5 * from &lt;foo&gt;;# 查询10条以后的数据db.&lt;foo&gt;.find().skip(10);# 等于SQL：select * from &lt;foo&gt; where id not in (select top 10 * from &lt;foo&gt;);# 查询在 5-10 之间的数据db.&lt;foo&gt;.find().limit(10).skip(5);# 可用于分页，limit 是 pageSize，skip 是第几页 pageSize# or查询db.&lt;foo&gt;.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;);# 等于SQL：select * from &lt;foo&gt; where age = 22 or age = 25;# 查询第一条数据db.&lt;foo&gt;.findOne();db.&lt;foo&gt;.find().limit(1);# 等于SQL：selecttop 1 * from &lt;foo&gt;;# 查询某个结果集的记录条数db.&lt;foo&gt;.find(&#123;age: &#123;$gte: 25&#125;&#125;).count();# 等于SQL：select count(*) from &lt;foo&gt; where age &gt;= 20;# 如果要返回限制之后的记录数量，要使用 count(true) 或 count(非0) db.users.find().skip(10).limit(5).count(true);# 按照某列进行排序db.&lt;foo&gt;.find(&#123;sex: &#123;$exists: true&#125;&#125;).count();# 等于SQL：select count(sex) from &lt;foo&gt;; 删除1db.users.remove(&#123;age: 132&#125;); 查询修改删除： 12345678910111213db.users.findAndModify(&#123; query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: 'a2'&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;);db.runCommand(&#123; findandmodify : \"users\", query: &#123;age: &#123;$gte: 25&#125;&#125;, sort: &#123;age: -1&#125;, update: &#123;$set: &#123;name: 'a2'&#125;, $inc: &#123;age: 2&#125;&#125;, remove: true&#125;);","categories":[{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"MongoDB","slug":"后端/MongoDB","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liweipeng88.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"MongoDB 数据库基本操作命令","slug":"MongoDB 数据库常用操作命令（一）","date":"2020-02-11T16:00:00.000Z","updated":"2020-07-22T01:42:53.330Z","comments":true,"path":"2020/02/12/MongoDB 数据库常用操作命令（一）/","link":"","permalink":"https://liweipeng88.github.io/2020/02/12/MongoDB%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"基本操作1234show dbs; # 查看数据库列表show collections; # 查看当前数据库中的集合（理解为MySQL中的表）show tables; # 同上show users; # 查看用户 数据库相关操作1234567891011use &lt;dbName&gt;; # 进入到 &lt;dbName&gt; 库，不存在则创建 db; # 查看当前所在库名db.help(); # 数据库命令帮助db.dropDatabase(); # 删除当前所在的库db.stats(); # 当前库状态db.repairDatabase(); # 修复当前数据库db.getMongo(); # 查看当前db的链接机器地址db.printCollectionStats(); # 显示当前db所有聚集索引的状态db.cloneDatabase(\"10.0.0.1\"); # 克隆 10.0.0.1 的库到本机db.copyDatabase(\"db1\", \"db2\", \"127.0.0.1\"); # 将本机 db1 库复制到 bd2 库中 集合操作集合操作需先进入库中 12345678910111213141516db.&lt;foo&gt;.help(); # 显示 &lt;foo&gt; 集合操作命令db.&lt;foo&gt;.find(); # 对于当前数据库中的 &lt;foo&gt; 集合进行数据查找db.getCollection(\"&lt;foo&gt;\").find(&#123;&#125;); # 同上db.&lt;foo&gt;.find(&#123;id:10&#125;); # 在 &lt;foo&gt; 集合中查找，条件是 id 等于 10db.createCollection('user'); # 创建一个 user 集合db.&lt;foo&gt;.count(); # 查询当前集合的数据条数db.&lt;foo&gt;.dataSize(); # 查看数据空间大小db.&lt;foo&gt;.getDB(); # 查看集合所在的库db.&lt;foo&gt;.stats(); # 查看集合的状态db.&lt;foo&gt;.totalSize(); # 集合总大小 db.&lt;foo&gt;.storageSize(); # 集合储存空间大小db.&lt;foo&gt;.drop(); # 删除集合db.&lt;foo&gt;.getShardVersion(); # Shard版本信息db.&lt;foo-1&gt;.renameCollection(\"&lt;foo-2&gt;\"); # 聚集集合重命名","categories":[{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"MongoDB","slug":"后端/MongoDB","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/MongoDB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://liweipeng88.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"vue-cli3项目搭建配置以及性能优化","slug":"vue3.0项目搭建和配置","date":"2020-02-10T16:00:00.000Z","updated":"2020-07-10T08:54:08.607Z","comments":true,"path":"2020/02/11/vue3.0项目搭建和配置/","link":"","permalink":"https://liweipeng88.github.io/2020/02/11/vue3.0%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"项目初始化 注意：安装前请确保有安装node.js，并且node&gt;=8.9 全局安装vue 1npm install -g @vue&#x2F;cli 如果之前安装了vue旧版本，查看vue –version 创建项目 1vue create vue-cli3-init(项目名) 注：名称不能采用驼峰 vue-cli3也可以采用UI面板进行配置，相对比较方便，目前先写命令行创建，后续再加上面板创建。 选择配置，默认配置还是手动，这里我选择手动Manually，继续回车会让你选择你想要功能。 （不用用git窗口，选择不了选项，可以使用上下方向来切换选项） 此处有两个选择： default (babel, eslint) 默认套餐，提供 babel 和 eslint 支持。 Manually select features 自己去选择需要的功能，提供更多的特性选择。比如如果想要支持 TypeScript，就应该选择这一项。 回车后可进行选择，8个功能特性，可以多选： 使用方向键在特性选项之间切换，使用空格键选中当前特性，使用 a 键切换选择所有，使用 i 键翻转选项。我的选择如下，请根据自己需要进行选择。 对于每一项的功能，此处做个简单描述： TypeScript 支持使用 TypeScript 书写源码。 Progressive Web App (PWA) Support PWA 支持。 Router 支持 vue-router 。 Vuex 支持 vuex 。 CSS Pre-processors 支持 CSS 预处理器。 Linter / Formatter 支持代码风格检查和格式化。 Unit Testing 支持单元测试。 E2E Testing 支持 E2E 测试。 是否选择history模式，根据自己需要选择。 是否选择预语言，根据自己需要选择。 是否ESlint输出，根据自己需要选择。 是否保存时或者提交时是进行ESlint校验，根据自己需要选择。 选择把配置文件放在外面，选择 In dedicated config files 要不要把当前的这一系列选项配置保存起来，方便下一次创建项目时复用。 项目初始化完成，进入项目: 123cd vue-cli3-init依赖安装完成之后启动项目：npm run serve 修改目录结构 用编辑器打开后可以看到目录结构。相对于vue-cli2精简了很多，减少了对webpack的配置。 node_modules 文件夹 项目依赖(对webpack进行了封装) public 文件夹 1.favicon.ico 是 网站图标 2.index.html 页面入口文件 src 文件夹 main.js 入口js assets 存放静态文件 components 存放公用组件 App.vue 入口vue文件 .eslintrc.js 配置 .gitignore 指定文件无需提交到git上 balel.config.js 使用一些预设 package.json 项目描述及依赖 package-lock.json 版本管理使用的文件 由于现在的目录结构不利于后期的开发，现在我们增加部分文件，待后续可以进行功能扩展。在src文件下：新建api文件夹，config文件夹,router文件夹，utils文件夹，views文件夹，store文件夹。并在其文件下建子目录，详细请参考目录截图： 多环境运行 由于我们的项目需要在不同环境下进行运行(开发，生产，测试等)，这避免我们需要多次的去切换请求的地址以及相关的配置，vue-cli2是可以直接在config文件中进行配置的，但是vue-cli3已经简化了，官方文档也有进行配置的说明，实现具体有以下2种方法，我比较偏向第二种。 第一种实现方法 1.在根目录新建2个文件，分别为.env.development，.env.production，.env.test。注意文件是只有后缀的。 .env.development 模式用于serve，开发环境，就是开始环境的时候会引用这个文件里面的配置 .env.production模式用于build，线上环境。 .env.test 测试环境 2.分别在文件内写上： 开发环境： 12&#x2F;&#x2F;.env.development VUE_APP_BASE_API &#x3D; &#39;需要请求API&#39; 线上环境： 12&#x2F;&#x2F;.env.productionVUE_APP_BASE_API &#x3D; &#39;需要请求API&#39; 测试环境： 12&#x2F;&#x2F;.env.testVUE_APP_BASE_API &#x3D; &#39;需要请求API&#39; 当需要用到该变量是可以用process.env.VUE_APP_BASE_API进行取值。 3.更改package.json文件 1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;test&quot;: &quot;vue-cli-service serve --mode test&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, 第二种实现方式 1.在config文件新建index.js文件，根据全局的环境变量来进行判断，并进行输出。代码如下： 12345678910111213141516171819&#x2F;&#x2F; 一些全局的config配置const modeUrlObj &#x3D; &#123; &#x2F;&#x2F; 生产环境 &#39;production&#39;: &#123; baseURL: &#39;http:&#x2F;&#x2F;xxx:9091&#x2F;pro&#x2F;&#39;, authBaseURL: &#39;&#39; &#125;, &#x2F;&#x2F; 开发环境 &#39;development&#39;: &#123; baseURL: &#39;http:&#x2F;&#x2F;xxxx:9091&#x2F;dev&#x2F;&#39;, authBaseURL: &#39;&#39; &#125;, &#x2F;&#x2F; 测试环境 &#39;test&#39;: &#123; baseURL: &#39;http:&#x2F;&#x2F;xxxx:9091&#x2F;test&#x2F;&#39;, authBaseURL: &#39;&#39; &#125;&#125;export default modeUrlObj[process.env.NODE_ENV] 2.更改package.json文件 1234567&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;test&quot;: &quot;vue-cli-service serve --mode test&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:test&quot;: &quot;vue-cli-service build --mode test&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, 3.引用的方法可以参照如下： 12import config from &#39;..&#x2F;config&#x2F;index&#39; &#x2F;&#x2F; 路径配置config.baseURL &#x2F;&#x2F; 对应环境api 4.运行命令行 1234npm run dev &#x2F;&#x2F; 开发环境npm run test &#x2F;&#x2F; 测试环境npm run build &#x2F;&#x2F; 正式环境打包npm run build:test &#x2F;&#x2F; 测试环境打包 axios封装 在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步axios文档。 安装依赖 1npm install axios --save; &#x2F;&#x2F; 安装axios 配置axios 在uitls文件下新增request.js文件，在这里我们对axios进行初始化后，暴露给需要引用的文件，方便开发。 12import axios from &#39;axios&#39;import config from &#39;..&#x2F;config&#x2F;index&#39; &#x2F;&#x2F; 路径配置 创建axios实例，并进行配置 12345&#x2F;&#x2F; 创建axios 实例const service &#x3D; axios.create(&#123; baseURL: config.baseURL, &#x2F;&#x2F; api的base_url timeout: 10000 &#x2F;&#x2F; 请求超时时间&#125;) 利用axios的请求拦截和响应拦截可以对登录和权限方面进行控制，具体需求可以自己进行配置。完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839import axios from &#39;axios&#39;import config from &#39;..&#x2F;config&#x2F;index&#39; &#x2F;&#x2F; 路径配置&#x2F;&#x2F; 创建axios 实例const service &#x3D; axios.create(&#123; baseURL: config.baseURL, &#x2F;&#x2F; api的base_url timeout: 10000 &#x2F;&#x2F; 请求超时时间&#125;)&#x2F;&#x2F; request 拦截器service.interceptors.request.use( config &#x3D;&gt; &#123; &#x2F;&#x2F; 这里可以自定义一些config 配置 return config &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 这里处理一些请求出错的情况 Promise.reject(error) &#125;)&#x2F;&#x2F; response 拦截器service.interceptors.response.use( response &#x3D;&gt; &#123; const res &#x3D; response.data &#x2F;&#x2F; 这里处理一些response 正常放回时的逻辑 return res &#125;, error &#x3D;&gt; &#123; &#x2F;&#x2F; 这里处理一些response 出错时的逻辑 return Promise.reject(error) &#125;)export default service api请求配置 在api文件下新建分类的api请求文件。根据具体需要分类。主要是方便团队开发，容易归类。可以参考下面配置。 12345678910111213141516171819import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123; &#x2F;&#x2F; 登录 login (data) &#123; return request(&#123; url: &#39;&#x2F;login&#39;, method: &#39;post&#39;, data &#125;) &#125;, &#x2F;&#x2F; 获取用户信息 getUserInfo () &#123; return request(&#123; url: &#39;&#x2F;userinfo&#39;, method: &#39;get&#39; &#125;) &#125;&#125; 业务中需要进行请求可以用import后，进行传参即可。 模块化vuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 如果对vuex还不大了解的可以自行阅读vuex官方文档。 安装vuex 1npm install vuex -S 新建目录 modules文件主要用法存放分类的文件，可以进行区分，getters文件是对state进行处理，index.js主要进行一些引入，初始化操作。 书写vuex配置 index.js文件 123456789101112131415import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import user from &#39;.&#x2F;modules&#x2F;user&#39; &#x2F;&#x2F; 引入各个模块的代码import getters from &#39;.&#x2F;getters&#39;Vue.use(Vuex)const store &#x3D; new Vuex.Store(&#123; modules: &#123; user &#125;, getters&#125;)export default store getter.js文件 getter中的配置可根据需求进行增加或者删除，下面是示例。 123456789const getters &#x3D; &#123; requestLoading: state &#x3D;&gt; state.app.requestLoading, size: state &#x3D;&gt; state.app.size, token: state &#x3D;&gt; state.user.token, avatar: state &#x3D;&gt; state.user.avatar, name: state &#x3D;&gt; state.user.name, roles: state &#x3D;&gt; state.user.roles&#125;export default getters moduels/user.js文件 该文件为与业务相关，可以跟据具体参见进行增加和删除命名。每个文件的基本配置和用法如下： 123456789101112131415161718192021222324252627282930313233import &#123; getToken, setToken &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;import api from &#39;@&#x2F;api&#x2F;user&#39;const user &#x3D; &#123; state: &#123; token: getToken(), &#125;, mutations: &#123; SET_TOKEN: (state, token) &#x3D;&gt; &#123; state.token &#x3D; token &#125;, &#125;, actions: &#123; &#x2F;&#x2F; 登录 Login (&#123; commit &#125;, userInfo) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; api.login(userInfo).then(res &#x3D;&gt; &#123; if (res.code &#x3D;&#x3D;&#x3D; 200) &#123; setToken(res.data) commit(&#39;SET_TOKEN&#39;, res.data) &#125; resolve() &#125;).catch(err &#x3D;&gt; &#123; reject(err) &#125;) &#125;) &#125; &#125;&#125;export default user 全局样式引用在项目开发过程中，我们经常需要全局样式引用，例如主题色等，如果每次去写的化会变得很麻烦。因为我们应该了sass预语言编译，所以可以大胆的应用其特性。例如变量，函数，混入等。但是我们需要在项目中进行全局的配置才能有效果。不用在每一个页面都进行引入样式，就能直接引用。 新建目录 在assets下新建如下文件，具体的代码自行进行配置 1234* common.scss 主要存放公共的样式* mixin.scss 存放混入样式* reset.scss 存放重置样式。* variable.scss 存放变量 全局引入 新建vue.config.js文件，并写上以下代码 12345678910111213141516module.exports &#x3D; &#123; css: &#123; loaderOptions: &#123; &#x2F;&#x2F; pass options to sass-loader sass: &#123; &#x2F;&#x2F; @&#x2F; is an alias to src&#x2F; &#x2F;&#x2F; so this assumes you have a file named &#96;src&#x2F;variables.scss&#96; data: &#96; @import &quot;@&#x2F;assets&#x2F;css&#x2F;variable.scss&quot;; @import &quot;@&#x2F;assets&#x2F;css&#x2F;common.scss&quot;; @import &quot;@&#x2F;assets&#x2F;css&#x2F;mixin.scss&quot;; &#96; &#125; &#125; &#125;,&#125; 在app.vue中引入reset.scss文件，完成后，样式即可进行全局调用了。 123&lt;style lang&#x3D;&quot;scss&quot;&gt; @import &quot;assets&#x2F;css&#x2F;reset&quot;;&lt;&#x2F;style&gt; 移动端适配配置在本项目中主要用rem来进行页面的适配操作的，因为rem就可以随根字体大小改变而改变，从而实现了自适应的功能。但是html的字体是固定的，所以需要监听页面大小的变化，我主要用了淘宝的amfe-flexible来进行监听改变的。将项目中css的px转成rem单位，免去计算烦恼,我们可以用scss来进行计算或者利用px2rem插件来进行自动转化。因为是开发移动端，需把mate换为``实现方法如下： 安装amfe-flexible 1npm i amfe-flexible --save px转rem 方法一： 在common.scss文件中，全局引入scss函数： 123456&#x2F;** 转化px为rem。$base-font-size &#x3D; 设计稿尺寸&#x2F;10*&#x2F;@function px2rem($px, $base-font-size: 37.5) &#123; @return ($px&#x2F;$base-font-size)*1rem&#125; 调用方式直接： width: px2rem(175); 方法二： 安装依赖 1npm i postcss-pxtorem --save-dev package.json内，在postcss内添加： 123456789&quot;postcss&quot;: &#123; &quot;plugins&quot;: &#123; &quot;autoprefixer&quot;: &#123;&#125;, &quot;postcss-pxtorem&quot;: &#123; &quot;rootValue&quot;: 75, &#x2F;&#x2F; 设计稿宽度的1&#x2F;10,（JSON文件中不加注释，此行注释及下行注释均删除） &quot;propList&quot;:[&quot;*&quot;] &#x2F;&#x2F; 需要做转化处理的属性，如&#96;hight&#96;、&#96;width&#96;、&#96;margin&#96;等，&#96;*&#96;表示全部 &#125; &#125; &#125;, 常用util该文件主要是对一些常用的js进行封装，例如时间格式化，LocalStorage操作等，相对比较常用的方法，这个文件可以进行保存，要用到时直接复制过来用即可。下面是我封装LocalStorage的文件，可参考以下，其他自行设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445import Cookies from &#39;js-cookie&#39;const TokenKey &#x3D; &#39;Authorization&#39;&#x2F;** 设置setLocalStorage* *&#x2F;export function setLocalStorage (key, value) &#123; window.localStorage.setItem(key, window.JSON.stringify(value))&#125;&#x2F;** 获取getLocalStorage* *&#x2F;export function getLocalStorage (key) &#123; return window.JSON.parse(window.localStorage.getItem(key) || &#39;[]&#39;)&#125;&#x2F;** 设置setSessionStorage* *&#x2F;export function setSessionStorage (key, value) &#123; window.sessionStorage.setItem(key, window.JSON.stringify(value))&#125;&#x2F;** 获取getSessionStorage* *&#x2F;export function getSessionStorage (key) &#123; return window.JSON.parse(window.sessionStorage.getItem(key) || &#39;[]&#39;)&#125;&#x2F;** 获取getToken* *&#x2F;export function getToken () &#123; return Cookies.get(TokenKey)&#125;&#x2F;** 设置setToken* *&#x2F;export function setToken (token) &#123; return Cookies.set(TokenKey, token)&#125;&#x2F;** 移除removeToken* *&#x2F;export function removeToken () &#123; return Cookies.remove(TokenKey)&#125; 引入第三方UI框架(elementUI) \\1. 打开控制台，执行vue add element命令，为项目安装element。 2.等待其安装完毕，在设置向导中配置引入方式和加载地区。 3.在自动安装完依赖后，可以看到相关的文件已经被创建/更新了。 4.如果需要按需引入，则去到src目录下自动新建的plugins目录，编辑element.js即可，默认会导入一个Button。这么做的好处是不用把引入的ele组件写在main.js文件下，使各模块更加分离。 配置vue.config.js文件基本配置 1.文件目录配置别名我们可以把src配置为@，如果需要就不用到根目录开始写了，直接用@/xxx/进行引用。根据自己需要进行配置，在vue.config.js文件中加入代码 12345678910111213&#x2F;&#x2F; 配置chainWebpack: (config)&#x3D;&gt;&#123;&#x2F;&#x2F; 配置别名config.resolve.alias .set(&#39;@&#39;, resolve(&#39;src&#39;)) .set(&#39;assets&#39;,resolve(&#39;src&#x2F;assets&#39;)) .set(&#39;components&#39;,resolve(&#39;src&#x2F;components&#39;)) .set(&#39;router&#39;,resolve(&#39;src&#x2F;router&#39;)) .set(&#39;utils&#39;,resolve(&#39;src&#x2F;utils&#39;)) .set(&#39;static&#39;,resolve(&#39;src&#x2F;static&#39;)) .set(&#39;store&#39;,resolve(&#39;src&#x2F;store&#39;)) .set(&#39;views&#39;,resolve(&#39;src&#x2F;views&#39;)) &#125; 2.跨域配置在前端请求过程中，如果后台没有设置跨域请求的，可以在webpack进行配置。 12345678devServer: &#123;proxy: &#123; &#39;&#x2F;api&#39;: &#123; target: &#39;http:&#x2F;&#x2F;127.0.0.1:8080&#39;, changeOrigin: true &#125; &#125;&#125; 3.其他配置 具体可以参照官网的配置说明，在项目中我用到了 123assetsDir: &#39;assets&#39;, &#x2F;&#x2F; 静态文件目录publicPath: &#39;.&#x2F;&#39;, &#x2F;&#x2F; 编译后的地址，可以根据环境进行设置lintOnSave: true, &#x2F;&#x2F; 是否开启编译时是否不符合eslint提示 以上的所有代码必须写在module.exports输出才能生效. 详细的配置可参考官网 vue-cli3 项目框架性能优化 (v1_mint_ui分支)通过以上的基本配置，项目已经符合我们工作需要了，但是在工作过程中会发现随着项目的集成度越来越高，业务越来越多。出现了加载慢和打包文件过大的问题。导致我们页面白屏时间过长，用户体验不友好。那么如果你感兴趣的话，可以进行以下的配置，可以大大大大大的减小体积和加载速度。在master分支是没有进行优化的，如果需要看优化代码可以到另外一个分支。所以在页面引入的代码都是当前页面需要的执行代码，可以往下面几个方法进行处理。 js,css代码的最小化压缩和分割 js,css代码公用代码提取, 按需引入(cdn加载) 图片文件的压缩 gzip的压缩 去除console.log 1.js,css代码的最小化压缩和分割 首先，我们先对js文件进行配置以达到压缩效果，先看一下没有配置代码情况，整个app.js 的文件是2.8M（因为是初始项目），但是如果页面一多，就不只这个数了。 我们会通过chainWebpak来处理. 在优化前, 看下相关文件的响应代码: 看下app.js文件的返回代码:代码如下： 在vue.config.js文件中加入,run以下后查看app.js情况，文件会变小（由于初始项目体积小，看不出多大区别）。 12345module.exports &#x3D; &#123; chainWebpack: config &#x3D;&gt; &#123; config.optimization.minimize(true); &#125;&#125; 分割代码,相应的文件中存入分割后的代码。 123456789module.exports &#x3D; &#123; chainWebpack: config &#x3D;&gt; &#123; config.optimization.minimize(true); config.optimization.splitChunks(&#123; chunks: &#39;all&#39; &#125;) &#125;&#125; 加入以上代码后，分成了2个文件，最大的只有2.7M了，这样可以分成多个进行加载，可以达到最快化，但是一定要平衡文件大小的和分割出来的文件数量的平衡, 数量多了, 请求也会变慢的, 影响性能.可以根据项目的进行设置，具体可参考官方文档的详细说明。 2.js,css代码公用代码提取, 按需引入(CDN加载) 把公用代码提取出来,然后采用使用免费的cdn资源进行加载。在项目中我们主要是引入引入不同的模块库才会导致文件较大，那么是否可以把这些文件进一步处理，答案是可以的，比如vue, vuex, vue-router, element-ui等公共资源库。利用webpack我们可以使用externals参数来配置: 在vue.config.js文件: 123456789101112131415161718module.exports &#x3D; &#123; chainWebpack: config &#x3D;&gt; &#123; &#x2F;&#x2F; 压缩代码 config.optimization.minimize(true); &#x2F;&#x2F; 分割代码 config.optimization.splitChunks(&#123; chunks: &#39;all&#39; &#125;) &#x2F;&#x2F; 用cdn方式引入 config.externals(&#123; &#39;vue&#39;: &#39;Vue&#39;, &#39;vuex&#39;: &#39;Vuex&#39;, &#39;vue-router&#39;: &#39;VueRouter&#39;, &#39;mint-ui&#39;: &#39;MINT&#39;, &#x2F;&#x2F; 需用MINT &#39;axios&#39;: &#39;axios&#39; &#125;) &#125;&#125; index.html加入CDN地址,注意引入的时候要写在body里面，否则会报错。 12345&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.6.10&#x2F;vue.runtime.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue-router&#x2F;3.0.2&#x2F;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vuex&#x2F;3.1.0&#x2F;vuex.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;axios&#x2F;0.18.0&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mint-ui&#x2F;2.2.13&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt; mint-ui样式通过CDN引入。然后商储mian.js文件的 import ‘mint-ui/lib/style.css’ （全局引入模式才有） 1&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mint-ui&#x2F;2.2.13&#x2F;style.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt; 如果需要引入其他依赖的CDN可以通过BootCDN查找进行引入。 重新运行项目, 看看效果，已经大大的减小了很多，到了k级别了： 提取css代码： 因为js会动态的加载出css，所以js文件包会比较大，那么需要提取css代码到文件. 这里我们只需要将css配置一下: 12345module.exports &#x3D; &#123; css: &#123; extract: true &#125;&#125; 3.图片文件的压缩 图片文件大于在webpack设定的值时，我们可以对其进行压缩在进行引入，安利给大家一个压缩图片的网站https://tinypng.com/，它可以批量的压缩图片又不会失真，压缩比相对较大。可以对图片进行有效压缩。 4.gzip的压缩 如果后台有对前端的代码进行gzip压缩的话，那么就不需要进行压缩了，后台自己配置就可以。如果后台不具备这种情况那么我们可以利用compression-webpack-plugin插件可以帮助我们进行gzip压缩： 安装依赖： 1npm install --save-dev compression-webpack-plugin 然后引入相关代码: 1234567891011121314151617181920212223242526272829303132const CompressionWebpackPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)const compress &#x3D; new CompressionWebpackPlugin( &#123; filename: info &#x3D;&gt; &#123; return &#96;$&#123;info.path&#125;.gz$&#123;info.query&#125;&#96; &#125;, algorithm: &#39;gzip&#39;, threshold: 10240, test: new RegExp( &#39;\\\\.(&#39; + [&#39;js&#39;].join(&#39;|&#39;) + &#39;)$&#39; ), minRatio: 0.8, deleteOriginalAssets: false &#125;)module.exports &#x3D; &#123;devServer: &#123; before(app, server) &#123; app.get(&#x2F;.*.(js)$&#x2F;, (req, res, next) &#x3D;&gt; &#123; req.url &#x3D; req.url + &#39;.gz&#39;; res.set(&#39;Content-Encoding&#39;, &#39;gzip&#39;); next(); &#125;) &#125; &#125; configureWebpack: &#123; plugins: [compress] &#125; 重新run一遍，出现了意向不到的结果了。又原来的2.8M转化为250+kb了，缩小了11倍以上。重大突破 6.去除console.log 正常情况下我们会在开发环境进行console调试，但是如果不删除，过多会出现内存泄漏的情况，那么我们可以在正式环境的时候就把它给干掉，实现方法如下： 方法一： 1234567891011121314151617181920212223242526const UglifyJsPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;);module.exports &#x3D; &#123; configureWebpack: config &#x3D;&gt; &#123; if (IS_PROD) &#123; const plugins &#x3D; []; plugins.push( new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, drop_debugger: false, pure_funcs: [&#39;console.log&#39;]&#x2F;&#x2F;移除console &#125; &#125;, sourceMap: false, parallel: true &#125;) ); config.plugins &#x3D; [ ...config.plugins, ...plugins ]; &#125; &#125;&#125; 方法二：使用babel-plugin-transform-remove-console插件 1npm i --save-dev babel-plugin-transform-remove-console 在babel.config.js中配置 123456789const plugins &#x3D; [];if([&#39;production&#39;, &#39;prod&#39;].includes(process.env.NODE_ENV)) &#123; plugins.push(&quot;transform-remove-console&quot;)&#125;module.exports &#x3D; &#123; presets: [[&quot;@vue&#x2F;app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]], plugins: plugins&#125;;","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Vue学习","slug":"web前端/Vue学习","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"Vue-如何封装axios并且统一管理api","slug":"Vue-如何封装axios并且统一管理api","date":"2020-01-18T16:00:00.000Z","updated":"2020-07-31T00:47:55.163Z","comments":true,"path":"2020/01/19/Vue-如何封装axios并且统一管理api/","link":"","permalink":"https://liweipeng88.github.io/2020/01/19/Vue-%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85axios%E5%B9%B6%E4%B8%94%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86api/","excerpt":"","text":"安装 123// 安装cnpm install axios cnpm install vue-axios 引入 在main.js中引入 1234// ajaximport axios from 'axios'import VueAxios from 'vue-axios'Vue.use(VueAxios, axios); 至此，我们可以在组件中使用axios发送get或者post请求了。但是响应处理以及请求拦截等我们还是需要统一封装的，接下来就需要封装axios。 封装 在src目录下面新增request文件夹。然后新增api文件夹，存放我们各个模块的api，新增index.js为各个模块api的统一出口。然后新增http.js封装axios。 目录结构如下 index.js 内容如下，index.js的功能就是统一导出各模块api,这样我们就不用在main.js中一个个去引入了。 1234567891011121314151617181920/** * api导出 */import userApi from '@/request/api/user';//用户管理模块import signApi from '@/request/api/sign';//登录注册模块import caseApi from '@/request/api/case';//病例模块import managerApi from '@/request/api/manager';//管理员模块import ringApi from '@/request/api/ring';//管理员模块import structApi from '@/request/api/struct';//管理员模块import scheduleApi from '@/request/api/schedule';//管理员模块export default &#123; userApi, signApi, caseApi, managerApi, ringApi, structApi, scheduleApi&#125; 以登陆模块为例子，sign.js如下，注意post和get传递参数的区别 123456789101112131415161718192021222324252627/*登录注册模块*/import axios from '@/request/http';import querystring from 'querystring';const signApi = &#123; //登录 signin(params)&#123; return axios.post('/signin/',querystring.stringify(params)); &#125;, //注册 signup(params)&#123; return axios.post('/signup/',querystring.stringify(params)); &#125;, //登出 signout(params)&#123; return axios.get('/signout/',&#123;params: params&#125;); &#125;, //获取验证码 getVerifyCodeImg(params)&#123; return axios.get('/getVrifyCode',&#123;params: params&#125;); &#125;&#125;;export default signApi; http.js内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//封装axiosimport Vue from 'vue'import axios from 'axios';import router from '../router';import store from '../store/index';import element from 'element-ui';let vueobj = new Vue();const toSignin = function (msg) &#123; store.dispatch(\"clearUserInfo\"); var message = msg ? msg : \"session过期，即将前往登录页面\"; vueobj.$message.error(&#123;showClose: true, message: message, duration: 3000, onClose: function () &#123; router.replace(&#123;path: '/signin', query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;); &#125;&#125;);&#125;/** * 请求失败后的错误统一处理 * @param &#123;Number&#125; status 请求失败的状态码 */const errorHandle = (status, other) =&gt; &#123; // 状态码判断 switch (status) &#123; case 400: vueobj.$message.error(&#123;showClose: true, message: \"请求参数有误！\", duration: 3000&#125;); break; // 401: 未登录状态，跳转登录页 case 401: //vueobj.$message.error(&#123;showClose: true, message: \"session过期，即将前往登录页面！\", duration: 3000&#125;); toSignin(); break; // 403 token过期 // 清除token并跳转登录页 case 403: vueobj.$message.error(&#123;showClose: true, message: \"没有操作权限！\", duration: 3000&#125;); break; // 404请求不存在 case 404: vueobj.$message.error(&#123;showClose: true, message: \"请求不存在\", duration: 3000&#125;); break; case 500: vueobj.$message.error(&#123;showClose: true, message: \"请求失败，服务器内部错误\", duration: 3000&#125;); break; case 504: vueobj.$message.error(&#123;showClose: true, message: \"与服务器连接失败！\", duration: 3000&#125;); break; default: console.log(other); &#125;&#125;// 创建axios实例var instance = axios.create(&#123; timeout: 1000 * 12&#125;);// 响应拦截器instance.interceptors.response.use( response =&gt; &#123; // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) &#123; if(typeof response.data != 'undefined')&#123; return Promise.resolve(response); &#125;else&#123; return Promise.reject(response); &#125; &#125; else &#123; return Promise.reject(response); &#125; &#125;, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; &#123; const &#123; response &#125; = error; if (response) &#123; // 请求已发出，但是不在2xx的范围 errorHandle(response.status, response.data.message); return Promise.reject(response); &#125; else &#123; // 处理断网的情况 // eg:请求超时或断网时，更新state的network状态 // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏 // 关于断网组件中的刷新重新获取数据，会在断网组件中说明 //store.commit('changeNetwork', false); //toSignin(); //vueobj.$message.error(&#123;showClose: true, message: \"与服务器连接失败！\", duration: 3000&#125;); var originalRequest = error.config; if(error.code == 'ECONNABORTED' &amp;&amp; error.message.indexOf('timeout')!=-1 &amp;&amp; !originalRequest._retry)&#123; // originalRequest._retry = true // return axios.request(originalRequest); vueobj.$message.error(&#123;showClose: true, message: \"请求超时，请稍后重试！\", duration: 3000&#125;); return Promise.reject(response); &#125;else&#123; &#125; &#125; &#125;);export default instance; 在main.js中引入 1234import api from './request/api/index'// 将各模块api挂载在vue实例上Vue.prototype.$api = api 至此我们已经将axios成功封装，并且将各个模块的api统一管理，如果后台人员修改了api路径，我们不用去组件中一一修改，只需要在api文件下的模块api作修改。接下来就是使用封装好的api了 使用 以登陆为例，可通过$api的方式访问我们封装的api了 123456789101112131415161718192021222324252627282930313233343536373839// 登陆 signin: function (formName) &#123; let that = this; that.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; that.loading = true; that.$api.signApi.signin(that.signinForm).then(function (response) &#123; if(response.data.code == '201')&#123; var userinfo = response.data.result; userinfo.isSignin = true; that.$store.dispatch(\"setUserInfo\", userinfo); setTimeout(function () &#123; var redirect = that.$route.query.redirect; if(redirect)&#123; that.$router.push(&#123;path: redirect&#125;); &#125;else&#123; if( that.$store.getters.isAdmin) &#123; that.$router.push(&#123;path: '/manage/user'&#125;); &#125;else&#123; that.$router.push(&#123;path: '/manage/case'&#125;); &#125; &#125; that.loading = false; &#125;,1000); &#125;else&#123; that.loading = false; that.$message.error(&#123;showClose: true, message: response.data.message, duration: 2000&#125;); &#125; &#125;).catch(function (response) &#123; that.loading = false; that.$message.error(&#123;showClose: true, message: response.data.message, duration: 2000&#125;); &#125;) &#125;else&#123; that.$message.error(&#123;showClose: true, message: that.$t('promotInfo.inputUnvalid'), duration: 2000&#125;); &#125; &#125;) &#125; 总结 本文讲述了如何封装axios并且统一管理各个模块的api，集中管理和统一封装的方式减少了代码的冗余，提高了系统的健壮性，对实际开发中协作开发也有很大帮助。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"web前端/Vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://liweipeng88.github.io/tags/VUE/"}],"author":"Li Weipeng"},{"title":"nodejs常用包","slug":"nodejs常用包","date":"2019-12-11T16:00:00.000Z","updated":"2020-06-10T08:18:47.683Z","comments":true,"path":"2019/12/12/nodejs常用包/","link":"","permalink":"https://liweipeng88.github.io/2019/12/12/nodejs%E5%B8%B8%E7%94%A8%E5%8C%85/","excerpt":"","text":"vue-lazyload图片懒加载，功能很全 axios支持 promise 的 http 库 amfe-flexible移动端适配 vue-meta组件中动态修改 head 标签里面的内容 webpack-bundle-analyzer打包完成后显示体积相关信息，可以了解是否重复加载,哪些文件过大等 html-webpack-include-assets-plugin用于添加 js 或 css 文件路径 vue-awesome-swiper移动端轮播图插件 swiper.animate1.0.3.min.js动画过渡插件 vue-wechat-title微信动态设置标题 uuid生成 uid(唯一标识符) md5md5 加密 weixin-js-sdk微信的 jssdk 库(微信分享) nodemon用 nodemon 来代替 node 来启动应用 rimraf以包的形式包装 rm -rf 命令，用来删除文件和文件夹的，不管文件夹是否为空，都可删除 babel-polyfillIE9 不支持 Promise,需安装 babel-polyfill qs数据格式转换插件，配合 axios 使用 fastclick移动端项目，点击事件会有 300ms 延迟的问题 1234567891011// main.jsimport FastClick from 'fastclick' // 解决移动端300毫秒延迟if ('addEventListener' in document) &#123; document.addEventListener( 'DOMContentLoaded', function() &#123; FastClick.attach(document.body) &#125;, false )&#125; fs-extrafs-extra 是 fs 的一个扩展 vue-contextmenu右键弹出菜单插件 vue-touch装了 hammer.js 的方法 vuex-persistedstatevuex 数据持久化 es6-promiserequire(‘es6-promise’).polyfill() vconsole手机端调试 console script-loader在全局上下文执行了一次 file.js 文档 123456789101112module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.exec\\.js$/, use: ['script-loader'] &#125; ] &#125;&#125;import exec from 'script-loader!./script.js' animate.csscss 动画库 1234567// main.js import animate from 'animate.css' Vue.use(animate)&lt;transition enter-active-class=\"animated zoomInLeft\" leave-active-class=\"animated zoomOutRight\"&gt;&lt;/transition&gt; vue-pano全景图插件 better-scroll滚动插件 vue-amap高德地图 vue-ba百度统计 vue-kindedtior富文本编辑器","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"nodejs","slug":"web前端/nodejs","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://liweipeng88.github.io/tags/nodejs/"}],"author":"Li Weipeng"},{"title":"setInterval与setTimeout的区别","slug":"setInterval与setTimeout的区别","date":"2019-11-21T16:00:00.000Z","updated":"2020-08-17T09:14:14.831Z","comments":true,"path":"2019/11/22/setInterval与setTimeout的区别/","link":"","permalink":"https://liweipeng88.github.io/2019/11/22/setInterval%E4%B8%8EsetTimeout%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"在制作网页动态效果时，一定会遇到某些需求，要求某段程序等待多时时间后再开始执行，就像在我们的生活中一样，待会儿再开始做一件事。在JavaScript中主要通过定时器实现此类需求，本文将对定时器做一个概括，正对setTimeout()做一个详细用法总结。 一.setInterval与setTimeout的区别setInterval setInterval()方法可按照指定的周期来调用函数或者计算表达式（以毫秒为单位） 语法： setInterval(函数表达式，毫秒数)； setInterval()会不停的调用函数，直到clearInterval()被调用或者窗口被关闭，由 setInterval()返回的ID值可用作clearInterval()方法的参数。 setTimeout setTimeout()方法用于在指定毫秒数后再调用函数或者计算表达式（以毫秒为单位） 语法： setTimeout(函数表达式，毫秒数)； setTimeout()只执行函数一次，如果需要多次调用可以使用setInterval(),或者在函数体内再次调用setTimeout() 区别 通过以上分析可以看出，setTimeout与setInterval的主要区别是: setTimeout()方法只运行一次，也就是说当达到设定的时间后就出发运行指定的代码，运行完后就结束了，如果还想再次执行同样的函数，可以在函数体内再次调用setTimeout()，可以达到循环调用的效果。 setInterval()是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，是真正的定时器。 二.setTimeout()的用法 先写个最简单的demo，如下： 1234567891011 1 &lt;!DOCTYPE html&gt; 2 &lt;html lang=\"en\"&gt; 3 &lt;head&gt; 4 &lt;meta charset=\"utf-8\"&gt; 5 &lt;script&gt; 6 setTimeout(\"alert('hello')\",2000); 7 &lt;/script&gt; 8 &lt;/head&gt; 9 &lt;body&gt;10 &lt;/body&gt;11 &lt;/html&gt; 页面会在停留2秒之后弹出对话框,注意setTimeout不会自动重复执行！ 当然，setTimeout也可以执行function，还可以不断重复执行！ 你可以看到h1中的文本数字在一秒一秒地递增！ 更加灵活的是，你还可以指定重复执行的次数，如下： if判断中的数字，是用来限制重复执行次数的条件。 三.clearTimeout()要使用clearTimeout()，需要我们设定setTimeout()时， 给予这setTimeout()一个名称, 这名称就是timeoutID ，我们叫停时，就是用这 timeoutID 来叫停 123456789101112 1 &lt;!DOCTYPE html&gt; 2 &lt;html lang=\"en\"&gt; 3 &lt;head&gt; 4 &lt;meta charset=\"utf-8\"&gt; 5 &lt;script&gt; 6 var timeId= setTimeout(\"alert('hello')\",2000); 7 clearTimeout(timeId); 8 &lt;/script&gt; 9 &lt;/head&gt;10 &lt;body&gt;11 &lt;/body&gt;12 &lt;/html&gt; 原计划1秒后弹出的警示框，被自然叫停了。","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"}],"author":"Li Weipeng"},{"title":"开发测试环境的灵活配置","slug":"开发、测试、生产环境的灵活配置","date":"2019-11-15T16:00:00.000Z","updated":"2020-06-15T01:11:05.332Z","comments":true,"path":"2019/11/16/开发、测试、生产环境的灵活配置/","link":"","permalink":"https://liweipeng88.github.io/2019/11/16/%E5%BC%80%E5%8F%91%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E7%81%B5%E6%B4%BB%E9%85%8D%E7%BD%AE/","excerpt":"","text":"12345678910111213const BASE_URL_DEV = 'http://192.168.0.63:8080/sfFinace/'const BASE_URL_TEST = 'http://192.168.0.63:8080/sfFinace/'const BASE_URL_PRO = 'http://192.168.0.63:8080/sfFinace/'const MODE_TYPE = &#123; DEV : 0, TEST: 1, PRO: 2&#125;const MODE = MODE_TYPE.DEVexport const BASE_URL = [BASE_URL_DEV, BASE_URL_TEST, BASE_URL_PRO][MODE]","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"web前端/vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"}],"author":"Li Weipeng"},{"title":"数据结构转换.js","slug":"数据结构转换","date":"2019-10-21T16:00:00.000Z","updated":"2020-08-17T04:29:03.570Z","comments":true,"path":"2019/10/22/数据结构转换/","link":"","permalink":"https://liweipeng88.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182join()push()和pop()shift() 和 unshift()sort()reverse()concat()slice()splice()indexOf()和 lastIndexOf() （ES5新增）forEach() （ES5新增）map() （ES5新增）filter() （ES5新增）every() （ES5新增）some() （ES5新增）//join，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)//书写格式：join(\" \")，括号里面写字符串 (\"要加引号\"),var arr = [1,2,3];console.log(arr.join()); // 1,2,3console.log(arr.join(\"-\")); // 1-2-3console.log(arr); // [1, 2, 3]（原数组不变） //push(): 把里面的内容添加到数组末尾，并返回修改后的长度。//书写格式：arr.push(\" \")，括号里面写内容 (\"字符串要加引号\"), //pop()：移除数组最后一项，返回移除的那个值，减少数组的length。//书写格式：arr.pop( )var arr = [\"Lily\",\"lucy\",\"Tom\"];var count = arr.push(\"Jack\",\"Sean\");console.log(count); // 5console.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]var item = arr.pop();console.log(item); // Seanconsole.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。 unshift:将参数添加到原数组开头，并返回数组的长度 。书写格式：arr.shift(\" \")，括号里面写内容 (\"字符串要加引号\"),var arr = [\"Lily\",\"lucy\",\"Tom\"];var count = arr.unshift(\"Jack\",\"Sean\");console.log(count); // 5console.log(arr); //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]var item = arr.shift();console.log(item); // Jackconsole.log(arr); // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]sort()：将数组里的项从小到大排序书写格式：arr.sort( )var arr1 = [\"a\", \"d\", \"c\", \"b\"];console.log(arr1.sort()); // [\"a\", \"b\", \"c\", \"d\"]sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数function sortNumber(a,b)&#123; return a - b&#125;arr = [13, 24, 51, 3]; console.log(arr.sort()); // [13, 24, 3, 51] console.log(arr.sort(sortNumber)); // [3, 13, 24, 51](数组被改变)reverse()：反转数组项的顺序。 书写格式：arr.reverse( )var arr = [13, 24, 51, 3];console.log(arr.reverse()); //[3, 51, 24, 13]console.log(arr); //[3, 51, 24, 13](原数组改变)concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 书写格式：arr.concat()，括号里面写内容 (\"字符串要加引号\"),var arr = [1,3,5,7];var arrCopy = arr.concat(9,[11,13]);console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7](原数组未被修改)slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。 书写格式：arr.slice( 1 , 3 )var arr = [1,3,5,7,9,11];var arrCopy = arr.slice(1);var arrCopy2 = arr.slice(1,4);var arrCopy3 = arr.slice(1,-2);var arrCopy4 = arr.slice(-4,-1);console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); //[3, 5, 7, 9, 11]console.log(arrCopy2); //[3, 5, 7]console.log(arrCopy3); //[3, 5, 7]console.log(arrCopy4); //[5, 7, 9] arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。 arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。 arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。splice()：删除、插入和替换。删除：指定 2 个参数：要删除的第一项的位置和要删除的项数。//书写格式：arr.splice( 1 , 3 )//插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。//书写格式：arr.splice( 2,0,4,6 )//替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。//书写格式：arr.splice( 2,0,4,6 )var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7]//indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。//书写格式：arr.indexof( 5 )//lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 //书写格式：arr.lastIndexOf( 5,4 )var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf(\"5\")); //-1//forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。//书写格式：arr.forEach()var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123;console.log(x + '|' + index + '|' + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true//map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。//书写格式：arr.map()var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123;return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25]//filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。//书写格式：arr.filter()var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) &#123;return index % 3 === 0 || x &gt;= 8;&#125;); console.log(arr2); //[1, 4, 7, 8, 9, 10]//every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。//书写格式：arr.every()var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) &#123;return x &lt; 10;&#125;); console.log(arr2); //truevar arr3 = arr.every(function(x) &#123;return x &lt; 3;&#125;); console.log(arr3); // false//some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。//书写格式：arr.some()var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) &#123;return x &lt; 3;&#125;); console.log(arr2); //truevar arr3 = arr.some(function(x) &#123;return x &lt; 1;&#125;); console.log(arr3); // false 123456789101112let protypeidList = []//将this.addForm.ptlist数组中的元素最后一个值取到，追加到新的数组protypeidList中this.addForm.ptlist.forEach(r =&gt; &#123; let id = r[r.length - 1] protypeidList.push(id)&#125;)//将ptlist数组遍历后取到值，再为每个值添加属性名后追到新的数组中let ptlist = []protypeidList.map(v =&gt; ptlist.push(&#123; protypeid: v&#125;))console.log(ptlist);","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"}],"author":"Li Weipeng"},{"title":"runtime.js","slug":"微信小程序es7转es5的runtime.js库","date":"2019-09-10T16:00:00.000Z","updated":"2020-06-10T08:25:49.628Z","comments":true,"path":"2019/09/11/微信小程序es7转es5的runtime.js库/","link":"","permalink":"https://liweipeng88.github.io/2019/09/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fes7%E8%BD%ACes5%E7%9A%84runtime.js%E5%BA%93/","excerpt":"","text":"1.在小程序的开发工具中，勾选es6转es5语法 2.下载Facebook的regenerator库中的regenerator/blob/master/packages/regenerator-runtime/runtime.js 3.在小程序目录下新建文件夹lib/runtime/runtime.js，将代码拷贝进去 4.在每个需要使用async语法的页面js文件中，都引入（不能全局引入） runtime.js链接地址 引用方式：importregeneratorRuntimefrom’../../lib/runtime/runtime’ 备注：只引用即可，就可以使用 async 加 await","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"插件","slug":"web前端/插件","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://liweipeng88.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Li Weipeng"},{"title":"移动端简单的适配处理","slug":"移动端简单的适配","date":"2019-07-12T16:00:00.000Z","updated":"2020-06-18T07:49:24.661Z","comments":true,"path":"2019/07/13/移动端简单的适配/","link":"","permalink":"https://liweipeng88.github.io/2019/07/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%82%E9%85%8D/","excerpt":"","text":"123456789101112131415161718192021 (function () &#123; // 在标准 375px 适配下，16px = 1rem; var baseFontSize = 16; var baseWidth = 375; var set = function () &#123; var clientWidth = document.documentElement.clientWidth || window.innerWidth; var rem = 16; if (clientWidth != baseWidth) &#123; rem = Math.floor(clientWidth / baseWidth * baseFontSize); &#125; document.querySelector('html').style.fontSize = rem + 'px'; &#125; set(); window.addEventListener('resize', set); &#125;());&lt;/script&gt; vscode编码的情况下，安装cssrem插件，将基准转换值设为16px，这样就可以正常用rem作为单位开发","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"移动端","slug":"web前端/移动端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://liweipeng88.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"author":"Li Weipeng"},{"title":"Bootstrap全部可用类名","slug":"Bootstrap全部可用类名","date":"2019-06-11T16:00:00.000Z","updated":"2020-07-16T10:01:40.563Z","comments":true,"path":"2019/06/12/Bootstrap全部可用类名/","link":"","permalink":"https://liweipeng88.github.io/2019/06/12/Bootstrap%E5%85%A8%E9%83%A8%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%90%8D/","excerpt":"","text":"CSS变量 变量名 值 颜色示意 –blue #007bff –indigo #6610f2 –purple #6f42c1 –pink #e83e8c –red #dc3545 –orange #fd7e14 –yellow #ffc107 –green #28a745 –teal #20c997 –cyan #17a2b8 –white #fff –gray #6c757d –gray-dark #343a40 –primary #007bff –secondary #6c757d –success #28a745 –info #17a2b8 –warning #ffc107 –danger #dc3545 –light #f8f9fa –dark #343a40 –breakpoint-xs 0 –breakpoint-sm 576px –breakpoint-md 768px –breakpoint-lg 992px –breakpoint-xl 1200px –font-family-sans-serif 无衬线字体序列 –font-family-monospace 等宽字体序列 侯娟霞 610121198010280040","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"UI库","slug":"web前端/UI库","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/UI%E5%BA%93/"}],"tags":[{"name":"UI库","slug":"UI库","permalink":"https://liweipeng88.github.io/tags/UI%E5%BA%93/"}],"author":"Li Weipeng"},{"title":"moment.js的方法总结","slug":"moment.js的方法总结","date":"2018-11-03T16:00:00.000Z","updated":"2020-06-10T08:24:54.146Z","comments":true,"path":"2018/11/04/moment.js的方法总结/","link":"","permalink":"https://liweipeng88.github.io/2018/11/04/moment.js%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"总结一个非常实用的日期工具类moment.js，日期获取，格式化等。 都是以前工作中遇到的，我会在使用工具类的时候新建一个js，工作中遇到要显示什么都在这个文件里尝试，所以这个顺序是我工作中遇到然后在js文件中尝试的顺序，可能顺序稍微乱一些，但是大致没有什么问题。 引入moment12345//require 方式var moment=require('moment');//import 方式import moment from 'moment'; 设定moment区域为中国123456//require 方式require('moment/locale/zh-cn')moment.locale('zh-cn'); //import 方式import 'moment/locale/zh-cn'moment.locale('zh-cn'); 格式化时间类型1.取当天时间，以YYYY年MM月DD日形式显示 1var now=moment().format(\"YYYY年MM月DD日\"); 2.任意时间戳格式化，以YYYY-MM-DD HH:mm:ss形式显示 1var t1=moment(1411641720000).format('YYYY-MM-DD HH:mm:ss'); 获取前一天日期，格式以YYYY-MM-DD形式显示1var t11=moment().day(0).format('YYYY-MM-DD'); 获取本周五日期，格式以YYYY-MM-DD形式显示1var t12=moment().weekday(5).format('YYYY-MM-DD'); 获取上周五日期，格式以YYYY-MM-DD形式显示1var t13=moment().weekday(-3).format('YYYY-MM-DD'); 可以简单理解为上周倒数第几天，上周倒数第三天就是上周五了，和当天日期无关 获取当前年份、月份、日期123var t14=moment().year()var t15=moment().month()//此处月份从0开始，当前月要+1var t16=moment().date(); 注意这个地方，日期不是.day()/days() 结合t14，t15，t16就可以输出你想要的任何和当前日期、月份相关的日期 例如：我想获取去年今天的完整日期，如：今天是2018-7-23，我要输出的是2017-7-23 1console.log(`$&#123;t14-1&#125;-$&#123;t15+1&#125;-$&#123;t16&#125;`) 当然这不是获取去年今天日期最好的办法，但你可以拼出很多你想要的组合，下面会介绍更好的获取去年今日的方法。 获取上个月今天的日期，格式以YYYY-MM-DD显示1var t18=moment().subtract(1, 'months').format('YYYY-MM-DD'); 获取上个月日期，格式以YYYY-MM显示1var t19=moment().subtract(1, 'months').format('YYYY-MM') 获取前一天日期，格式以YYYY-MM-DD显示1var t20 = moment().subtract(1, 'days').format('YYYY-MM-DD'); 获取去年今天的日期，格式以YYYY-MM-DD显示，即简便的获取去年今天日期的方法1var t21= moment().subtract(1, 'year').format('YYYY-MM-DD'); 获取两个小时之后的时间1var t22=moment().add(2,'hours').format('YYYY-MM-DD HH:mm:ss'); 这个的应用是获取时间戳过期时间 比较也很简单，只要获取当前时间，一样的format用&gt;&lt;=号比较就可以了 获取五天前的日期例如:今天2018-7-23，获取到的时间是2018-7-18 1var t23=moment().subtract(5, 'days').format('YYYY-MM-DD');","categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"插件","slug":"web前端/插件","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"常用插件","slug":"常用插件","permalink":"https://liweipeng88.github.io/tags/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"}],"author":"Li Weipeng"}],"categories":[{"name":"web前端","slug":"web前端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"web前端/JS","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/JS/"},{"name":"Vue","slug":"web前端/Vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue/"},{"name":"Echarts","slug":"web前端/Echarts","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Echarts/"},{"name":"vue","slug":"web前端/vue","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/vue/"},{"name":"其他","slug":"其他","permalink":"https://liweipeng88.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"内网穿透","slug":"其他/内网穿透","permalink":"https://liweipeng88.github.io/categories/%E5%85%B6%E4%BB%96/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"UI库","slug":"web前端/UI库","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/UI%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"框架","slug":"后端/框架","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/"},{"name":"Vue学习","slug":"web前端/Vue学习","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/Vue%E5%AD%A6%E4%B9%A0/"},{"name":"MongoDB","slug":"后端/MongoDB","permalink":"https://liweipeng88.github.io/categories/%E5%90%8E%E7%AB%AF/MongoDB/"},{"name":"nodejs","slug":"web前端/nodejs","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/nodejs/"},{"name":"插件","slug":"web前端/插件","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E6%8F%92%E4%BB%B6/"},{"name":"移动端","slug":"web前端/移动端","permalink":"https://liweipeng88.github.io/categories/web%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://liweipeng88.github.io/tags/JS/"},{"name":"VUE","slug":"VUE","permalink":"https://liweipeng88.github.io/tags/VUE/"},{"name":"Echarts","slug":"Echarts","permalink":"https://liweipeng88.github.io/tags/Echarts/"},{"name":"vue","slug":"vue","permalink":"https://liweipeng88.github.io/tags/vue/"},{"name":"其他","slug":"其他","permalink":"https://liweipeng88.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"UI库","slug":"UI库","permalink":"https://liweipeng88.github.io/tags/UI%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"https://liweipeng88.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://liweipeng88.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"nodejs","slug":"nodejs","permalink":"https://liweipeng88.github.io/tags/nodejs/"},{"name":"小程序","slug":"小程序","permalink":"https://liweipeng88.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"移动端","slug":"移动端","permalink":"https://liweipeng88.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"常用插件","slug":"常用插件","permalink":"https://liweipeng88.github.io/tags/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"}]}